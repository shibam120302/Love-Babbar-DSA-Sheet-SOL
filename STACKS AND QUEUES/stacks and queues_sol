-----------------------------------------------------------------------
                              Stacks and Queues
-----------------------------------------------------------------------

Implement Stack from Scratch	
---------------------------------------

It is a linear data structure that follows a particular order in which the operations are performed.

LIFO( Last In First Out ):

This strategy states that the element that is inserted last will come out first. You can take a pile of plates kept on top of each other as a real-life example. The plate which we put last is on the top and since we remove the plate that is at the top, we can say that the plate that was put last comes out first. 

Basic Operations on Stack
In order to make manipulations in a stack, there are certain operations provided to us.

push() to insert an element into the stack
pop() to remove an element from the stack
top() Returns the top element of the stack.
isEmpty() returns true is stack is empty else false
size() returns the size of stack

Push: 
Adds an item to the stack. If the stack is full, then it is said to be an Overflow condition.

Algorithm for push:

begin
 if stack is full
    return
 endif
else  
 increment top
 stack[top] assign value
end else
end procedure

Pop:
Removes an item from the stack. The items are popped in the reversed order in which they are pushed. If the stack is empty, then it is said to be an Underflow condition.

Algorithm for pop:

begin
 if stack is empty
    return
 endif
else
 store value of stack[top]
 decrement top
 return value
end else
end procedure

Top:
Returns the top element of the stack.

Algorithm for Top:

begin 
  return stack[top]
end procedure

isEmpty:
Returns true if the stack is empty, else false.

Algorithm for isEmpty:

begin
 if top < 1
    return true
 else
    return false
end procedure

Understanding stack practically:
There are many real-life examples of a stack. Consider the simple example of plates stacked over one another in a canteen. The plate which is at the top is the first one to be removed, i.e. the plate which has been placed at the bottommost position remains in the stack for the longest period of time. So, it can be simply seen to follow the LIFO/FILO order.

Complexity Analysis:  
Time Complexity
Operations  	Complexity
push() 	         O(1)
pop()   	     O(1)
isEmpty() 	     O(1)
size()	         O(1)

Types of Stacks:
Register Stack: This type of stack is also a memory element present in the memory unit and can handle a small amount of data only. The height of the register stack is always limited as the size of the register stack is very small compared to the memory.
Memory Stack: This type of stack can handle a large amount of memory data. The height of the memory stack is flexible as it occupies a large amount of memory data. 
Applications of the stack:
Infix to Postfix /Prefix conversion
Redo-undo features at many places like editors, photoshop.
Forward and backward features in web browsers
Used in many algorithms like Tower of Hanoi, tree traversals, stock span problems, and histogram problems.
Backtracking is one of the algorithm designing techniques. Some examples of backtracking are the Knight-Tour problem, N-Queen problem, find your way through a maze, and game-like chess or checkers in all these problems we dive into someway if that way is not efficient we come back to the previous state and go into some another path. To get back from a current state we need to store the previous state for that purpose we need a stack.
In Graph Algorithms like Topological Sorting and Strongly Connected Components
In Memory management, any modern computer uses a stack as the primary management for a running purpose. Each program that is running in a computer system has its own memory allocations
String reversal is also another application of stack. Here one by one each character gets inserted into the stack. So the first character of the string is on the bottom of the stack and the last element of a string is on the top of the stack. After Performing the pop operations on the stack we get a string in reverse order.

Implementation of Stack: 
There are two ways to implement a stack
Using array
Using linked list

Implementing Stack using Arrays:

/* C++ program to implement basic stack operations */
#include <bits/stdc++.h>
using namespace std;
#define MAX 1000
  
class Stack {
    int top;
  
public:
    int a[MAX]; // Maximum size of Stack
  
    Stack() { top = -1; }
    bool push(int x);
    int pop();
    int peek();
    bool isEmpty();
};
  
bool Stack::push(int x)
{
    if (top >= (MAX - 1)) {
        cout << "Stack Overflow";
        return false;
    }
    else {
        a[++top] = x;
        cout << x << " pushed into stack\n";
        return true;
    }
}
  
int Stack::pop()
{
    if (top < 0) {
        cout << "Stack Underflow";
        return 0;
    }
    else {
        int x = a[top--];
        return x;
    }
}
int Stack::peek()
{
    if (top < 0) {
        cout << "Stack is Empty";
        return 0;
    }
    else {
        int x = a[top];
        return x;
    }
}
  
bool Stack::isEmpty()
{
    return (top < 0);
}
  
// Driver program to test above functions
int main()
{
    class Stack s;
    s.push(10);
    s.push(20);
    s.push(30);
    cout << s.pop() << " Popped from stack\n";
    
    //print top element of stack after poping
    cout << "Top element is : " << s.peek() << endl;
    
    //print all elements in stack :
    cout <<"Elements present in stack : ";
    while(!s.isEmpty())
    {
        // print top element in stack
        cout << s.peek() <<" ";
        // remove top element in stack
        s.pop();
    }
  
    return 0;
}
Output
10 pushed into stack
20 pushed into stack
30 pushed into stack
30 Popped from stack
Top element is : 20
Elements present in stack : 20 10 

Advantages of array implementation:
Easy to implement.
Memory is saved as pointers are not involved. 

Disadvantages of array implementation:
It is not dynamic.
It doesn’t grow and shrink depending on needs at runtime.

Implementing Stack using Linked List:

// C++ program for linked list implementation of stack
#include <bits/stdc++.h>
using namespace std;
  
// A structure to represent a stack
class StackNode {
public:
    int data;
    StackNode* next;
};
  
StackNode* newNode(int data)
{
    StackNode* stackNode = new StackNode();
    stackNode->data = data;
    stackNode->next = NULL;
    return stackNode;
}
  
int isEmpty(StackNode* root)
{
    return !root;
}
  
void push(StackNode** root, int data)
{
    StackNode* stackNode = newNode(data);
    stackNode->next = *root;
    *root = stackNode;
    cout << data << " pushed to stack\n";
}
  
int pop(StackNode** root)
{
    if (isEmpty(*root))
        return INT_MIN;
    StackNode* temp = *root;
    *root = (*root)->next;
    int popped = temp->data;
    free(temp);
  
    return popped;
}
  
int peek(StackNode* root)
{
    if (isEmpty(root))
        return INT_MIN;
    return root->data;
}
  
// Driver code
int main()
{
    StackNode* root = NULL;
  
    push(&root, 10);
    push(&root, 20);
    push(&root, 30);
  
    cout << pop(&root) << " popped from stack\n";
  
    cout << "Top element is " << peek(root) << endl;
      
    cout <<"Elements present in stack : ";
     //print all elements in stack :
    while(!isEmpty(root))
    {
        // print top element in stack
        cout << peek(root) <<" ";
        // remove top element in stack
        pop(&root);
    }
  
    return 0;
}
  
Output
10 pushed to stack
20 pushed to stack
30 pushed to stack
30 popped from stack
Top element is 20
Elements present in stack : 20 10

Advantages of Linked List implementation:
The linked list implementation of a stack can grow and shrink according to the needs at runtime.
It is used in many virtual machines like JVM.
Stacks are more secure and reliable as they do not get corrupted easily.
Stack cleans up the objects automatically.

Disadvantages of Linked List implementation:                                                                                         
Requires extra memory due to the involvement of pointers.
Random accessing is not possible in stack.
The total size of the stack must be defined before.
If the stack falls outside the memory it can lead to abnormal termination.

Implement Queue from Scratch	
-----------------------------------
Similar to Stack, Queue is a linear data structure that follows a particular order in which the operations are performed for storing data. The order is First In First Out (FIFO). One can imagine a queue as a line of people waiting to receive something in sequential order which starts from the beginning of the line. It is an ordered list in which insertions are done at one end which is known as the rear and deletions are done from the other end known as the front. A good example of a queue is any queue of consumers for a resource where the consumer that came first is served first. 
The difference between stacks and queues is in removing. In a stack we remove the item the most recently added; in a queue, we remove the item the least recently added.

Basic Operations on Queue: 

enqueue(): Inserts an element at the end of the queue i.e. at the rear end.
dequeue(): This operation removes and returns an element that is at the front end of the queue.
front(): This operation returns the element at the front end without removing it.
rear(): This operation returns the element at the rear end without removing it.
Empty(): This operation indicates whether the queue is empty or not.
size(): This operation returns the size of the queue i.e. the total number of elements it contains.  

Types of Queues: 
Simple Queue: Simple queue also known as a linear queue is the most basic version of a queue. Here, insertion of an element i.e. the Enqueue operation takes place at the rear end and removal of an element i.e. the Dequeue operation takes place at the front end.
Circular Queue:  In a circular queue, the element of the queue act as a circular ring. The working of a circular queue is similar to the linear queue except for the fact that the last element is connected to the first element. Its advantage is that the memory is utilized in a better way. This is because if there is an empty space i.e. if no element is present at a certain position in the queue, then an element can be easily added at that position.
Priority Queue: This queue is a special type of queue. Its specialty is that it arranges the elements in a queue based on some priority. The priority can be something where the element with the highest value has the priority so it creates a queue with decreasing order of values. The priority can also be such that the element with the lowest value gets the highest priority so in turn it creates a queue with increasing order of values.
Dequeue: Dequeue is also known as Double Ended Queue. As the name suggests double ended, it means that an element can be inserted or removed from both ends of the queue, unlike the other queues in which it can be done only from one end. Because of this property, it may not obey the First In First Out property. 

Applications of Queue: 

Queue is used when things don’t have to be processed immediately, but have to be processed in First In First Out order like Breadth First Search. This property of Queue makes it also useful in following kind of scenarios.

When a resource is shared among multiple consumers. Examples include CPU scheduling, Disk Scheduling. 
When data is transferred asynchronously (data not necessarily received at same rate as sent) between two processes. Examples include IO Buffers, pipes, file IO, etc. 
Queue can be used as an essential component in various other data structures.

Array implementation Of Queue:
For implementing queue, we need to keep track of two indices, front and rear. We enqueue an item at the rear and dequeue an item from the front. If we simply increment front and rear indices, then there may be problems, the front may reach the end of the array. The solution to this problem is to increase front and rear in circular manner.

Steps for enqueue:
Check the queue is full or not
If full, print overflow and exit
If queue is not full, increment tail and add the element

Steps for dequeue:
Check queue is empty or not
if empty, print underflow and exit
if not empty, print element at the head and increment head

// CPP program for array implementation of queue
#include <bits/stdc++.h>
using namespace std;
  
// A structure to represent a queue
class Queue {
public:
    int front, rear, size;
    unsigned capacity;
    int* array;
};
  
// function to create a queue of given capacity.It initializes size of queue as 0
Queue* createQueue(unsigned capacity)
{
    Queue* queue = new Queue();
    queue->capacity = capacity;
    queue->front = queue->size = 0;
  
    // This is important, see the enqueue
    queue->rear = capacity - 1;
    queue->array = new int[queue->capacity];
    return queue;
}
  
// Queue is full when size becomes equal to the capacity
int isFull(Queue* queue)
{
    return (queue->size == queue->capacity);
}
  
// Queue is empty when size is 0
int isEmpty(Queue* queue)
{
    return (queue->size == 0);
}
  
// Function to add an item to the queue.It changes rear and size
void enqueue(Queue* queue, int item)
{
    if (isFull(queue))
        return;
    queue->rear = (queue->rear + 1)
                  % queue->capacity;
    queue->array[queue->rear] = item;
    queue->size = queue->size + 1;
    cout << item << " enqueued to queue\n";
}
  
// Function to remove an item from queue.
// It changes front and size
int dequeue(Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    int item = queue->array[queue->front];
    queue->front = (queue->front + 1)
                   % queue->capacity;
    queue->size = queue->size - 1;
    return item;
}
  
// Function to get front of queue
int front(Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    return queue->array[queue->front];
}
  
// Function to get rear of queue
int rear(Queue* queue)
{
    if (isEmpty(queue))
        return INT_MIN;
    return queue->array[queue->rear];
}
  
// Driver code
int main()
{
    Queue* queue = createQueue(1000);
  
    enqueue(queue, 10);
    enqueue(queue, 20);
    enqueue(queue, 30);
    enqueue(queue, 40);
  
    cout << dequeue(queue)
         << " dequeued from queue\n";
  
    cout << "Front item is "
         << front(queue) << endl;
    cout << "Rear item is "
         << rear(queue) << endl;
  
    return 0;
} 
Output
10 enqueued to queue
20 enqueued to queue
30 enqueued to queue
40 enqueued to queue
10 dequeued from queue
Front item is 20
Rear item is 40
Complexity Analysis:  
Time Complexity
Operations  	  Complexity
Enqueue(insertion) 	O(1)
Deque(deletion)   	O(1)
Front(Get front)   	O(1)
Rear(Get Rear)	    O(1)
                           
Auxiliary Space: 
O(N) where N is the size of the array for storing elements.

Advantages of Array Implementation:  
Easy to implement.
A large amount of data can be managed efficiently with ease.
Operations such as insertion and deletion can be performed with ease as it follows the first in first out rule.

Disadvantages of Array Implementation:  
Static Data Structure, fixed size.
If the queue has a large number of enqueue and dequeue operations, at some point (in case of linear increment of front and rear indexes) we may not be able to insert elements in the queue even if the queue is empty (this problem is avoided by using circular queue).

Implement 2 stack in an array	
-------------------------------------------
Create a data structure twoStacks that represent two stacks. Implementation of twoStacks should use only one array, i.e., both stacks should use the same array for storing elements. 

Following functions must be supported by twoStacks.

push1(int x) –> pushes x to first stack 
push2(int x) –> pushes x to second stack
pop1() –> pops an element from first stack and return the popped element 
pop2() –> pops an element from second stack and return the popped element
Implementation of twoStack should be space efficient.

By Dividing the space into two halves:

The idea to implement two stacks is to divide the array into two halves and assign two halves to two stacks, i.e., use arr[0] to arr[n/2] for stack1, and arr[(n/2) + 1] to arr[n-1] for stack2 where arr[] is the array to be used to implement two stacks and size of array be n. 

Follow the steps below to solve the problem:

To implement push1():
First, check whether the top1 is greater than 0 
If it is then add an element at the top1 index and decrement top1 by 1
Else return Stack Overflow

To implement push2():
First, check whether top2 is less than n – 1
If it is then add an element at the top2 index and increment the top2 by 1
Else return Stack Overflow

To implement pop1():
First, check whether the top1 is less than or equal to n / 2
If it is then increment the top1 by 1 and return that element.
Else return Stack Underflow

To implement pop2():
First, check whether the top2 is greater than or equal to (n + 1) / 2
If it is then decrement the top2 by 1 and return that element.
Else return Stack Underflow

#include <bits/stdc++.h>
using namespace std;
 
class twoStacks {
    int* arr;
    int size;
    int top1, top2;
 
public:
    // Constructor
    twoStacks(int n)
    {
        size = n;
        arr = new int[n];
        top1 = n / 2 + 1;
        top2 = n / 2;
    }
 
    // Method to push an element x to stack1
    void push1(int x)
    {
        // There is at least one empty space for new element
        if (top1 > 0) {
            top1--;
            arr[top1] = x;
        }
        else {
            cout << "Stack Overflow"
                 << " By element : " << x << endl;
            return;
        }
    }
 
    // Method to push an element x to stack2
    void push2(int x)
    {
 
        // There is at least one empty space for new element
        if (top2 < size - 1) {
            top2++;
            arr[top2] = x;
        }
        else {
            cout << "Stack Overflow"
                 << " By element : " << x << endl;
            return;
        }
    }
 
    // Method to pop an element from first stack
    int pop1()
    {
        if (top1 <= size / 2) {
            int x = arr[top1];
            top1++;
            return x;
        }
        else {
            cout << "Stack UnderFlow";
            exit(1);
        }
    }
 
    // Method to pop an element from second stack
    int pop2()
    {
        if (top2 >= size / 2 + 1) {
            int x = arr[top2];
            top2--;
            return x;
        }
        else {
            cout << "Stack UnderFlow" << endl;
            exit(1);
        }
    }
};
 
/* Driver program to test twoStacks class */
int main()
{
    twoStacks ts(5);
    ts.push1(5);
    ts.push2(10);
    ts.push2(15);
    ts.push1(11);
    ts.push2(7);
    cout << "Popped element from stack1 is "
         << ": " << ts.pop1() << endl;
    ts.push2(40);
    cout << "Popped element from stack2 is "
         << ": " << ts.pop2() << endl;
    return 0;
}
Output
Stack Overflow By element : 7
Popped element from stack1 is : 11
Stack Overflow By element : 40
Popped element from stack2 is : 15

Time Complexity: 
Push operation: O(1)
Pop operation: O(1)
Auxiliary Space: O(N), Use of array to implement stack.

By Starting from endpoints:

The idea is to start two stacks from two extreme corners of arr[]. 

Follow the steps below to solve the problem:

Stack1 starts from the leftmost element, the first element in stack1 is pushed at index 0. 
Stack2 starts from the rightmost corner, the first element in stack2 is pushed at index (n-1). 
Both stacks grow (or shrink) in opposite directions. 
To check for overflow, all we need to check is for space between top elements of both stacks.

#include <iostream>
#include <stdlib.h>
using namespace std;
 
class twoStacks {
    int* arr;
    int size;
    int top1, top2;
 
public:
    twoStacks(int n) // constructor
    {
        size = n;
        arr = new int[n];
        top1 = -1;
        top2 = size;
    }
 
    // Method to push an element x to stack1
    void push1(int x)
    {
        // There is at least one empty space for new element
        if (top1 < top2 - 1) {
            top1++;
            arr[top1] = x;
        }
        else {
            cout << "Stack Overflow";
            exit(1);
        }
    }
 
    // Method to push an element x to stack2
    void push2(int x)
    {
        // There is at least one empty
        // space for new element
        if (top1 < top2 - 1) {
            top2--;
            arr[top2] = x;
        }
        else {
            cout << "Stack Overflow";
            exit(1);
        }
    }
 
    // Method to pop an element from first stack
    int pop1()
    {
        if (top1 >= 0) {
            int x = arr[top1];
            top1--;
            return x;
        }
        else {
            cout << "Stack UnderFlow";
            exit(1);
        }
    }
 
    // Method to pop an element from second stack
    int pop2()
    {
        if (top2 < size) {
            int x = arr[top2];
            top2++;
            return x;
        }
        else {
            cout << "Stack UnderFlow";
            exit(1);
        }
    }
};
 
/* Driver program to test twoStacks class */
int main()
{
    twoStacks ts(5);
    ts.push1(5);
    ts.push2(10);
    ts.push2(15);
    ts.push1(11);
    ts.push2(7);
    cout << "Popped element from stack1 is " << ts.pop1();
    ts.push2(40);
    cout << "\nPopped element from stack2 is " << ts.pop2();
    return 0;
}
Output
Popped element from stack1 is 11
Popped element from stack2 is 40

Time Complexity: 
Push operation: O(1)
Pop operation: O(1)
Auxiliary Space: O(N), Use of the array to implement stack.

Find the middle element of a stack	
---------------------------------------
How to implement a stack which will support the following operations in O(1) time complexity? 
1) push() which adds an element to the top of stack. 
2) pop() which removes an element from top of stack. 
3) findMiddle() which will return middle element of the stack. 
4) deleteMiddle() which will delete the middle element. 
Push and pop are standard stack operations. 

Method 1:
The important question is, whether to use a linked list or array for the implementation of the stack? 
Please note that we need to find and delete the middle element. Deleting an element from the middle is not O(1) for the array. Also, we may need to move the middle pointer up when we push an element and move down when we pop(). In a singly linked list, moving the middle pointer in both directions is not possible. 
The idea is to use a Doubly Linked List (DLL). We can delete the middle element in O(1) time by maintaining mid pointer. We can move the mid pointer in both directions using previous and next pointers. 
Following is implementation of push(), pop() and findMiddle() operations. If there are even elements in stack, findMiddle() returns the second middle element. For example, if stack contains {1, 2, 3, 4}, then findMiddle() would return 3. 
 
/* C++ Program to implement a stack that supports findMiddle() and deleteMiddle in O(1) time */
#include <bits/stdc++.h>
using namespace std;
 
class myStack {
    struct Node {
        int num;
        Node* next;
        Node* prev;
 
        Node(int num) { this->num = num; }
    };
 
    // Members of stack
    Node* head = NULL;
    Node* mid = NULL;
    int size = 0;
 
public:
    void push(int data)
    {
        Node* temp = new Node(data);
        if (size == 0) {
            head = temp;
            mid = temp;
            size++;
            return;
        }
 
        head->next = temp;
        temp->prev = head;
 
        // update the pointers
        head = head->next;
        if (size % 2 == 1) {
            mid = mid->next;
        }
        size++;
    }
 
    int pop()
    {
      int data=-1;
        if (size != 0) {
          data=head->num;
            if (size == 1) {
                head = NULL;
                mid = NULL;
            }
            else {
                head = head->prev;
                head->next = NULL;
                if (size % 2 == 0) {
                    mid = mid->prev;
                }
            }
            size--;
        }
      return data;
    }
 
    int findMiddle()
    {
        if (size == 0) {
            return -1;
        }
        return mid->num;
    }
 
    void deleteMiddle()
    {
        if (size != 0) {
            if (size == 1) {
                head = NULL;
                mid = NULL;
            }
            else if (size == 2) {
                head = head->prev;
                mid = mid->prev;
                head->next = NULL;
            }
            else {
                mid->next->prev = mid->prev;
                mid->prev->next = mid->next;
                if (size % 2 == 0) {
                    mid = mid->prev;
                }
                else {
                    mid = mid->next;
                }
            }
            size--;
        }
    }
};
 
int main()
{
    myStack st;
    st.push(11);
    st.push(22);
    st.push(33);
    st.push(44);
    st.push(55);
    st.push(66);
    st.push(77);
    st.push(88);
    st.push(99);
    cout <<"Popped : "<< st.pop() << endl;
    cout <<"Popped : "<< st.pop() << endl;
    cout <<"Middle Element : "<< st.findMiddle() << endl;
    st.deleteMiddle();
    cout <<"New Middle Element : "<< st.findMiddle() << endl;
    return 0;
}

Output
Popped : 99
Popped : 88
Middle Element : 44
New Middle Element : 55

Method 2: Using a standard stack and a deque 

We will use a standard stack to store half of the elements and the other half of the elements which were added recently will be present in the deque. Insert operation on myStack will add an element into the back of the deque. The number of elements in the deque stays 1 more or equal to that in the stack, however, whenever the number of elements present in the deque exceeds the number of elements in the stack by more than 1 we pop an element from the front of the deque and push it into the stack. The pop operation on myStack will remove an element from the back of the deque. If after the pop operation, the size of the deque is less than the size of the stack, we pop an element from the top of the stack and insert it back into the front of the deque so that size of the deque is not less than the stack. We will see that the middle element is always the front element of the deque. So deleting of the middle element can be done in O(1) if we just pop the element from the front of the deque. 

Consider Operations on My_stack:
Operation                  stack                  deque

add(2)                      { }                    {2}
add(5)                      {2}                    {5}
add(3)                      {2}                    {5,3}
add(7)                      {2,5}                  {3,7}
add(4)                      {2,5}                  {3,7,4}
deleteMiddle()              {2,5}                  {7,4}
deleteMiddle()              {2}                    {5,4}
pop()                       {2}                    {5}
pop()                       { }                    {2}
deleteMiddle()              { }                    { }

#include <bits/stdc++.h>
using namespace std;
 
class myStack {
    stack<int> st;
    deque<int> dq;
 
public:
    void add(int data)
    {
        dq.push_back(data);
        if (dq.size() > st.size() + 1) {
            int temp = dq.front();
            dq.pop_front();
            st.push(temp);
        }
    }
 
    void pop()
    {
        int data = dq.back();
        dq.pop_back();
        if (st.size() > dq.size()) {
            int temp = st.top();
            st.pop();
            dq.push_front(temp);
        }
    }
 
    int getMiddleElement() {
      return dq.front();
    }
 
    void deleteMiddleElement()
    {
        dq.pop_front();
        if (st.size() > dq.size()) { // new middle element
            int temp = st.top();     // should come at front of deque
            st.pop();
            dq.push_front(temp);
        }
    }
};
 
int main()
{
    myStack st;
    st.add(2);
    st.add(5);
    cout << "Middle Element: " << st.getMiddleElement() << endl;
    st.add(3);
    st.add(7);
    st.add(4);
    cout << "Middle Element: " << st.getMiddleElement() << endl;
    st.deleteMiddleElement();
    cout << "Middle Element: " << st.getMiddleElement() << endl;
    st.deleteMiddleElement();
    cout << "Middle Element: " << st.getMiddleElement() << endl;
    st.pop();
    st.pop();
    st.deleteMiddleElement();
}
 
Output
Middle Element: 5
Middle Element: 3
Middle Element: 7
Middle Element: 5

Implement “N” stacks in an Array	
----------------------------------------
Create a data structure kStacks that represents k stacks. Implementation of kStacks should use only one array, i.e., k stacks should use the same array for storing elements. 

Following functions must be supported by kStacks. push(int x, int sn) –> pushes x to stack number ‘sn’ where sn is from 0 to k-1 pop(int sn) –> pops an element from stack number ‘sn’ where sn is from 0 to k-1 

Method 1 (Divide the array in slots of size n/k) A simple way to implement k stacks is to divide the array in k slots of size n/k each, and fix the slots for different stacks, i.e., use arr[0] to arr[n/k-1] for first stack, and arr[n/k] to arr[2n/k-1] for stack2 where arr[] is the array to be used to implement two stacks and size of array be n. The problem with this method is inefficient use of array space. A stack push operation may result in stack overflow even if there is space available in arr[]. For example, say the k is 2 and array size (n) is 6 and we push 3 elements to first and do not push anything to second second stack. When we push 4th element to first, there will be overflow even if we have space for 3 more elements in array. 

Method 2 (A space efficient implementation) The idea is to use two extra arrays for efficient implementation of k stacks in an array. This may not make much sense for integer stacks, but stack items can be large for example stacks of employees, students, etc where every item is of hundreds of bytes. For such large stacks, the extra space used is comparatively very less as we use two integer arrays as extra space. 

Following are the two extra arrays are used: 


1) top[]: This is of size k and stores indexes of top elements in all stacks. 

2) next[]: This is of size n and stores indexes of next item for the items in array arr[]. 

Here arr[] is actual array that stores k stacks. Together with k stacks, a stack of free slots in arr[] is also maintained. The top of this stack is stored in a variable ‘free’. All entries in top[] are initialized as -1 to indicate that all stacks are empty. All entries next[i] are initialized as i+1 because all slots are free initially and pointing to next slot. Top of free stack, ‘free’ is initialized as 0. 

Following is implementation of the above idea. 

// A C++ program to demonstrate implementation of k stacks in a single 
// array in time and space efficient way
#include<bits/stdc++.h>
using namespace std;
  
// A C++ class to represent k stacks in a single array of size n
class kStacks
{
    int *arr;   // Array of size n to store actual content to be stored in stacks
    int *top;   // Array of size k to store indexes of top elements of stacks
    int *next;  // Array of size n to store next entry in all stacks
                // and free list
    int n, k;
    int free; // To store beginning index of free list
public:
    //constructor to create k stacks in an array of size n
    kStacks(int k, int n);
  
    // A utility function to check if there is space available
    bool isFull()   {  return (free == -1);  }
  
    // To push an item in stack number 'sn' where sn is from 0 to k-1
    void push(int item, int sn);
  
    // To pop an from stack number 'sn' where sn is from 0 to k-1
    int pop(int sn);
  
    // To check whether stack number 'sn' is empty or not
    bool isEmpty(int sn)  {  return (top[sn] == -1); }
};
  
//constructor to create k stacks in an array of size n
kStacks::kStacks(int k1, int n1)
{
    // Initialize n and k, and allocate memory for all arrays
    k = k1, n = n1;
    arr = new int[n];
    top = new int[k];
    next = new int[n];
  
    // Initialize all stacks as empty
    for (int i = 0; i < k; i++)
        top[i] = -1;
  
    // Initialize all spaces as free
    free = 0;
    for (int i=0; i<n-1; i++)
        next[i] = i+1;
    next[n-1] = -1;  // -1 is used to indicate end of free list
}
  
// To push an item in stack number 'sn' where sn is from 0 to k-1
void kStacks::push(int item, int sn)
{
    // Overflow check
    if (isFull())
    {
        cout << "\nStack Overflow\n";
        return;
    }
  
    int i = free;      // Store index of first free slot
  
    // Update index of free slot to index of next slot in free list
    free = next[i];
  
    // Update next of top and then top for stack number 'sn'
    next[i] = top[sn];
    top[sn] = i;
  
    // Put the item in array
    arr[i] = item;
}
  
// To pop an from stack number 'sn' where sn is from 0 to k-1
int kStacks::pop(int sn)
{
    // Underflow check
    if (isEmpty(sn))
    {
         cout << "\nStack Underflow\n";
         return INT_MAX;
    }
  
  
    // Find index of top item in stack number 'sn'
    int i = top[sn];
  
    top[sn] = next[i];  // Change top to store next of previous top
  
    // Attach the previous top to the beginning of free list
    next[i] = free;
    free = i;
  
    // Return the previous top item
    return arr[i];
}
  
/* Driver program to test twoStacks class */
int main()
{
    // Let us create 3 stacks in an array of size 10
    int k = 3, n = 10;
    kStacks ks(k, n);
  
    // Let us put some items in stack number 2
    ks.push(15, 2);
    ks.push(45, 2);
  
    // Let us put some items in stack number 1
    ks.push(17, 1);
    ks.push(49, 1);
    ks.push(39, 1);
  
    // Let us put some items in stack number 0
    ks.push(11, 0);
    ks.push(9, 0);
    ks.push(7, 0);
  
    cout << "Popped element from stack 2 is " << ks.pop(2) << endl;
    cout << "Popped element from stack 1 is " << ks.pop(1) << endl;
    cout << "Popped element from stack 0 is " << ks.pop(0) << endl;
  
    return 0;
}
Output:
Popped element from stack 2 is 45
Popped element from stack 1 is 39
Popped element from stack 0 is 7

Time complexities of operations push() and pop() is O(1). The best part of above implementation is, if there is a slot available in stack, then an item can be pushed in any of the stacks, i.e., no wastage of space.
Time Complexity: O(N), as we are using a loop to traverse N times.
Auxiliary Space: O(N), as we are using extra space for stack.

Check the expression has valid or Balanced parenthesis or not
-----------------------------------------------------------------------

Given an expression string exp, write a program to examine whether the pairs and the orders of “{“, “}”, “(“, “)”, “[“, “]” are correct in the given expression.

Example: 

Input: exp = “[()]{}{[()()]()}” 
Output: Balanced
Explanation: all the brackets are well-formed

Input: exp = “[(])” 
Output: Not Balanced 
Explanation: 1 and 4 brackets are not balanced because 
there is a closing ‘]’ before the closing ‘(‘

Using Stack:
The idea is to put all the opening brackets in the stack. Whenever you hit a closing bracket, search if the top of the stack is the opening bracket of the same nature. If this holds then pop the stack and continue the iteration, in the end if the stack is empty, it means all brackets are well-formed . Otherwise, they are not balanced.

Illustration: 























Follow the steps mentioned below to implement the idea:

Declare a character stack (say temp).
Now traverse the string exp. 
If the current character is a starting bracket ( ‘(‘ or ‘{‘  or ‘[‘ ) then push it to stack.
If the current character is a closing bracket ( ‘)’ or ‘}’ or ‘]’ ) then pop from stack and if the popped character is the matching starting bracket then fine.
Else brackets are Not Balanced.
After complete traversal, if there is some starting bracket left in stack then Not balanced, else Balanced.


















// C++ program to check for balanced brackets.
#include <bits/stdc++.h>
using namespace std;
 
// Function to check if brackets are balanced
bool areBracketsBalanced(string expr)
{
    // Declare a stack to hold the previous brackets.
    stack<char> temp;
    for (int i = 0; i < expr.length(); i++) {
        if (temp.empty()) {
             
            // If the stack is empty
            // just push the current bracket
            temp.push(expr[i]);
        }
        else if ((temp.top() == '(' && expr[i] == ')')
                 || (temp.top() == '{' && expr[i] == '}')
                 || (temp.top() == '[' && expr[i] == ']')) {
             
            // If we found any complete pair of bracket
            // then pop
            temp.pop();
        }
        else {
            temp.push(expr[i]);
        }
    }
    if (temp.empty()) {
         
        // If stack is empty return true
        return true;
    }
    return false;
}
 
// Driver code
int main()
{
    string expr = "{()}[]";
 
    // Function call
    if (areBracketsBalanced(expr))
        cout << "Balanced";
    else
        cout << "Not Balanced";
    return 0;
}
Output
Balanced
Time Complexity: O(N), Iteration over the string of size N one time.
Auxiliary Space: O(N) for stack. 

Reverse a String using Stack	
----------------------------------------
Given string str consisting of multiple words, the task is to reverse the entire string word by word.
Examples:  

Input: str = “I Love To Code” 
Output: Code To Love I
Input: str = “data structures and algorithms” 
Output: algorithms and structures data 

Approach: This problem can be solved not only with the help of the strtok() but also it can be solved by using Stack Container Class in STL C++ by following the given steps:  

Create an empty stack.
Traverse the entire string, while traversing add the characters of the string into a temporary 
variable until you get a space(‘ ‘) and push that temporary variable into the stack.
Repeat the above step until the end of the string.
Pop the words from the stack until the stack is not empty which will be in reverse order.

//C++ implementation of the above approach
#include<bits/stdc++.h>
using namespace std;
 
//function to reverse the words
//of the given string without using strtok().
void reverse(string s)
{
  //create an empty string stack
  stack<string> stc;
 
  //create an empty temporary string
  string temp="";
 
  //traversing the entire string
  for(int i=0;i<s.length();i++)
  {
    if(s[i]==' ')
    {
       
      //push the temporary variable into the stack
      stc.push(temp);
       
      //assigning temporary variable as empty
      temp="";         
    }
    else
    {
      temp=temp+s[i];
    }
 
  }
 
  //for the last word of the string
  stc.push(temp);
 
  while(!stc.empty()) {
 
    // Get the words in reverse order
    temp=stc.top();
    cout<<temp<<" ";
    stc.pop();
  }
  cout<<endl;
}
 
//Driver code
int main()
{
  string s="I Love To Code";
  reverse(s);
  return 0;
}
Output: 
Code To Love I
Time Complexity: O(N), for traversing over the string.
Auxiliary Space: O(N), for storing the words in the string.

Using stack is discussed here. This problem can also be solved using stack by following the below steps: 

Create an empty stack.
Tokenize the input string into words using spaces as separator with the help of strtok()
Push the words into the stack.
Pop the words from the stack until the stack is not empty which will be in reverse order.

// C++ implementation of the approach
#include <bits/stdc++.h>
using namespace std;
 
// Function to reverse the words of the given sentence
void reverse(char k[])
{
 
    // Create an empty character array stack
    stack<char*> s;
    char* token = strtok(k, " ");
 
    // Push words into the stack
    while (token != NULL) {
        s.push(token);
        token = strtok(NULL, " ");
    }
 
    while (!s.empty()) {
 
        // Get the words in reverse order
        cout << s.top() << " ";
        s.pop();
    }
}
 
// Driver code
int main()
{
    char k[] = "geeks for geeks";
    reverse(k);
 
    return 0;
}
Output: 
geeks for geeks
Time Complexity: O(N), for traversing over the string.
Auxiliary Space: O(N), for storing the words in the string.

Design a Stack that supports getMin() in O(1) time and O(1) extra space.	
--------------------------------------------------------------------------
Design a Data Structure SpecialStack that supports all the stack operations like push(), pop(), isEmpty(), isFull() and an additional operation getMin() which should return minimum element from the SpecialStack. All these operations of SpecialStack must have a time and space complexity of O(1). 
Note: To implement SpecialStack, you should only use standard Stack data structure and no other data structure like arrays, lists, etc

Example: 

Input: Consider the following SpecialStack

16  –> TOP
15
29
19
18

When getMin() is called it should return 15, 
which is the minimum element in the current stack. 

If we do pop two times on stack, the stack becomes

29  –> TOP
19
18

When getMin() is called, it should return 18 
which is the minimum in the current stack.

Approach: To solve the problem follow the below idea:

We define a variable minEle that stores the current minimum element in the stack. Now the interesting part is, how to handle the case when the minimum element is removed. To handle this, we push “2x – minEle” into the stack instead of x so that the previous minimum element can be retrieved using the current minEle and its value stored in the stack

Follow the given steps to implement the stack operations:

Push(x): Insert x at the top of the stack

If the stack is empty, insert x into the stack and make minEle equal to x.
If the stack is not empty, compare x with minEle. Two cases arise:
If x is greater than or equal to minEle, simply insert x.
If x is less than minEle, insert (2*x – minEle) into the stack and make minEle equal to x. 
For example, let the previous minEle be 3. Now we want to insert 2. We update minEle as 2 and insert 2*2 – 3 = 1 into the stack

Pop(): Removes an element from the top of the stack

Remove the element from the top. Let the removed element be y. Two cases arise:
If y is greater than or equal to minEle, the minimum element in the stack is still minEle.
If y is less than minEle, the minimum element now becomes (2*minEle – y), so update (minEle = 2*minEle – y). This is where we retrieve the previous minimum from the current minimum and its value in the stack. 
For example, let the element to be removed be 1 and minEle be 2. We remove 1 and update minEle as 2*2 – 1 = 3

Important Points: 

Stack doesn’t hold the actual value of an element if it is minimum so far.
The actual minimum element is always stored in the minEle variable

Push(x) 














Number to be Inserted: 3, Stack is empty, so insert 3 into stack and minEle = 3.
Number to be Inserted: 5, Stack is not empty, 5> minEle, insert 5 into stack and minEle = 3.
Number to be Inserted: 2, Stack is not empty, 2< minEle, insert (2*2-3 = 1) into stack and minEle = 2.
Number to be Inserted: 1, Stack is not empty, 1< minEle, insert (2*1-2 = 0) into stack and minEle = 1.
Number to be Inserted: 1, Stack is not empty, 1 = minEle, insert 1 into stack and minEle = 1.
Number to be Inserted: -1, Stack is not empty, -1 < minEle, insert (2*-1 – 1 = -3) into stack and minEle = -1.

Pop() 



















Initially the minimum element minEle in the stack is -1.
Number removed: -3, Since -3 is less than the minimum element the original number being removed is minEle which is -1, and the new minEle = 2*-1 – (-3) = 1
Number removed: 1, 1 == minEle, so number removed is 1 and minEle is still equal to 1.
Number removed: 0, 0< minEle, original number is minEle which is 1 and new minEle = 2*1 – 0 = 2.
Number removed: 1, 1< minEle, original number is minEle which is 2 and new minEle = 2*2 – 1 = 3.
Number removed: 5, 5> minEle, original number is 5 and minEle is still 3

// C++ program to implement a stack that supports
// getMinimum() in O(1) time and O(1) extra space.
#include <bits/stdc++.h>
using namespace std;
 
// A user defined stack that supports getMin() in addition to push() and pop()
struct MyStack {
    stack<int> s;
    int minEle;
 
    // Prints minimum element of MyStack
    void getMin()
    {
        if (s.empty())
            cout << "Stack is empty\n";
 
        // variable minEle stores the minimum element in the stack.
        else
            cout << "Minimum Element in the stack is: "
                 << minEle << "\n";
    }
 
    // Prints top element of MyStack
    void peek()
    {
        if (s.empty()) {
            cout << "Stack is empty ";
            return;
        }
 
        int t = s.top(); // Top element.
 
        cout << "Top Most Element is: ";
 
        // If t < minEle means minEle stores value of t.
        (t < minEle) ? cout << minEle : cout << t;
    }
 
    // Remove the top element from MyStack
    void pop()
    {
        if (s.empty()) {
            cout << "Stack is empty\n";
            return;
        }
 
        cout << "Top Most Element Removed: ";
        int t = s.top();
        s.pop();
 
        // Minimum will change as the minimum element
        // of the stack is being removed.
        if (t < minEle) {
            cout << minEle << "\n";
            minEle = 2 * minEle - t;
        }
 
        else
            cout << t << "\n";
    }
 
    // Removes top element from MyStack
    void push(int x)
    {
        // Insert new number into the stack
        if (s.empty()) {
            minEle = x;
            s.push(x);
            cout << "Number Inserted: " << x << "\n";
            return;
        }
 
        // If new number is less than minEle
        else if (x < minEle) {
            s.push(2 * x - minEle);
            minEle = x;
        }
 
        else
            s.push(x);
 
        cout << "Number Inserted: " << x << "\n";
    }
};
 
// Driver Code
int main()
{
    MyStack s;
   
      // Function calls
    s.push(3);
    s.push(5);
    s.getMin();
    s.push(2);
    s.push(1);
    s.getMin();
    s.pop();
    s.getMin();
    s.pop();
    s.peek();
 
    return 0;
}
Output
Number Inserted: 3
Number Inserted: 5
Minimum Element in the stack is: 3
Number Inserted: 2
Number Inserted: 1
Minimum Element in the stack is: 1
Top Most Element Removed: 1
Minimum Element in the stack is: 2
Top Most Element Removed: 2
Top Most Element is: 5
cpp-stl-self-paced-course

How does this approach work? 
When the element to be inserted is less than minEle, we insert “2x – minEle”. The important thing to note is, that 2x – minEle will always be less than x (proved below), i.e., new minEle and while popping out this element we will see that something unusual has happened as the popped element is less than the minEle. So we will be updating minEle.

How 2*x – minEle is less than x in push()? 

x < minEle which means x – minEle < 0
 

// Adding x on both sides
x – minEle + x < 0 + x 
2*x – minEle < x 
We can conclude 2*x – minEle < new minEle 

While popping out, if we find the element(y) less than the current minEle, we find the new minEle = 2*minEle – y

How previous minimum element, prevMinEle is, 2*minEle – y
in pop() is y the popped element?

 // We pushed y as 2x – prevMinEle. Here prevMinEle is minEle before y was inserted

y = 2*x – prevMinEle  

// Value of minEle was made equal to x
minEle = x .

new minEle = 2 * minEle – y 
                   = 2*x – (2*x – prevMinEle)
                   = prevMinEle // This is what we wanted

Design a stack that supports getMin() in O(1) time and O(1) extra space by creating a MinStack class:
To solve the problem follow the below idea:

Create a class node that has two variables Val and min.  Val will store the actual value that we are going to insert in the stack, whereas min will store the min value so far seen up to that node

// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;
 
int mini(int a, int b) { return a > b ? b : a; }
 
class MinStack {
public:
    stack<pair<int, int> > s;
 
    void push(int element)
    {
        /* new max will be given no. if stack is empty else
        we compare given no. to max at current top of
        stack*/
 
        int new_min = s.empty()
                          ? element
                          : mini(element, s.top().second);
 
        // we push the pair of given_element,new_min in s
 
        s.push({ element, new_min });
    }
 
    int pop()
    {
        int popped;
        if (!s.empty()) {
            // popped has popped number
            popped = s.top().first;
            s.pop();
        }
        else {
            // print a message or throw exception etc
        }
        return popped;
    }
 
    int minimum()
    {
        int min_elem = s.top().second;
        return min_elem;
    }
};
 
// Driver code
int main()
{
    MinStack s;
   
      // Function calls
    s.push(-1);
    s.push(10);
    s.push(-4);
    s.push(0);
    cout << s.minimum() << endl;
    cout << s.pop() << endl;
    cout << s.pop() << endl;
    cout << s.minimum();
    return 0;
}
 
Output
-4
0
-4
-1

Find the next Greater element	
-----------------------------------
Given an array, print the Next Greater Element (NGE) for every element. 

The Next greater Element for an element x is the first greater element on the right side of x in the array. Elements for which no greater element exist, consider the next greater element as -1. 

Example: 

Input: arr[] = [ 4 , 5 , 2 , 25 ]
Output:      4      –>   5
             5      –>   25
             2      –>   25
             25     –>   -1
Explanation: except 25 every element has an element greater than them present on the right side

Input: arr[] = [ 13 , 7, 6 , 12 ]
Output:      13      –>    -1
             7       –>     12
             6       –>     12
             12      –>     -1
Explanation: 13 and 12 don’t have any element greater than them present on the right side

Using Nested Loops:
The idea is to use two loops , The outer loop picks all the elements one by one. The inner loop looks for the first greater element for the element picked by the outer loop. If a greater element is found then that element is printed as next, otherwise, -1 is printed.



Follow the steps mentioned below to implement the idea:

Traverse The array from index 0 to end.
For each element start another loop from index i+1 to end.
If a greater element is found in the second loop then print it and break the loop, else print -1.                

// Simple C++ program to print next greater elements in a given array
#include <iostream>
using namespace std;
 
/* prints element and NGE pair
for all elements of arr[] of size n */
void printNGE(int arr[], int n)
{
    int next, i, j;
    for (i = 0; i < n; i++) {
        next = -1;
        for (j = i + 1; j < n; j++) {
            if (arr[i] < arr[j]) {
                next = arr[j];
                break;
            }
        }
        cout << arr[i] << " --> " << next << endl;
    }
}
 
// Driver Code
int main()
{
    int arr[] = { 11, 13, 21, 3 };
    int n = sizeof(arr) / sizeof(arr[0]);
    printNGE(arr, n);
    return 0;
}

Time Complexity: O(N2) 
Auxiliary Space: O(1)

Find Next Greater Element using Stack:
The idea is to store the elements for which we have to find the next greater element in a stack and while traversing the array, if we find a greater element, we will pair it with the elements from the stack till the top element of the stack is less than the current element.

Illustration:

Follow the steps mentioned below to implement the idea:

Push the first element to stack.
Pick the rest of the elements one by one and follow the following steps in the loop. 
Mark the current element as next.
If the stack is not empty, compare top most element of stack with next.
If next is greater than the top element, Pop element from the stack. next is the next greater element for the popped element.
Keep popping from the stack while the popped element is smaller than next. next becomes the next greater element for all such popped elements.
Finally, push the next in the stack.
After the loop in step 2 is over, pop all the elements from the stack and print -1 as the next element for them.           

// A Stack based C++ program to find next greater element for all array elements.
#include <bits/stdc++.h>
using namespace std;
 
/* prints element and NGE pair for all
elements of arr[] of size n */
void printNGE(int arr[], int n)
{
    stack<int> s;
 
    /* push the first element to stack */
    s.push(arr[0]);
 
    // iterate for rest of the elements
    for (int i = 1; i < n; i++) {
 
        if (s.empty()) {
            s.push(arr[i]);
            continue;
        }
 
        /* if stack is not empty, then
           pop an element from stack.
           If the popped element is smaller
           than next, then
        a) print the pair
        b) keep popping while elements are
        smaller and stack is not empty */
        while (s.empty() == false && s.top() < arr[i]) {
            cout << s.top() << " --> " << arr[i] << endl;
            s.pop();
        }
 
        /* push next to stack so that we can find
        next greater for it */
        s.push(arr[i]);
    }
 
    /* After iterating over the loop, the remaining
    elements in stack do not have the next greater
    element, so print -1 for them */
    while (s.empty() == false) {
        cout << s.top() << " --> " << -1 << endl;
        s.pop();
    }
}
 
/* Driver code */
int main()
{
    int arr[] = { 11, 13, 21, 3 };
    int n = sizeof(arr) / sizeof(arr[0]);
    printNGE(arr, n);
    return 0;
}
Time Complexity: O(N) 
Auxiliary Space: O(N) 

Find Next Greater Element using Map: 
In this particular approach we are using the map as our main stack

This is same as above method but the elements are pushed and popped only once into the stack. The array is changed in place. The array elements are pushed into the stack until it finds a greatest element in the right of array. In other words the elements are popped from stack when top of the stack value is smaller in the current array element.
Once all the elements are processed in the array but stack is not empty. The left out elements in the stack doesn’t encounter any greatest element . So pop the element from stack and change it’s index value as -1 in the array.

// C++ code to implement the approach
#include <bits/stdc++.h>
using namespace std;
 
void nextLargerElement(int arr[], int n)
{
    vector<unordered_map<string, int> > s;
 
    // iterating over the array
    for (int i = 0; i < n; i++) {
        while (s.size() > 0
               && s[s.size() - 1]["value"] < arr[i]) {
            // updating the array as per the stack top
            unordered_map<string, int> d = s[s.size() - 1];
            s.pop_back();
            arr[d["ind"]] = arr[i];
        }
        // pushing values to stack
        unordered_map<string, int> e;
 
        e["value"] = arr[i];
        e["ind"] = i;
        s.push_back(e);
    }
 
    // updating the array as per the stack top
    while (s.size() > 0) {
        unordered_map<string, int> d = s[s.size() - 1];
        s.pop_back();
        arr[d["ind"]] = -1;
    }
}
 
// Driver Code
int main()
{
    int arr[] = { 6, 8, 0, 1, 3 };
    int n = 5;
 
    // Function call
    nextLargerElement(arr, n);
    for (int i = 0; i < n; i++)
        cout << arr[i] << " ";
}
 
Output
8 -1 1 3 -1 
Time Complexity: O(N) 
Auxiliary Space: O(N)

The celebrity Problem	
---------------------------------
In a party of N people, only one person is known to everyone. Such a person may be present in the party, if yes, (s)he doesn’t know anyone in the party. We can only ask questions like “does A know B? “. Find the stranger (celebrity) in the minimum number of questions.
We can describe the problem input as an array of numbers/characters representing persons in the party. We also have a hypothetical function HaveAcquaintance(A, B) which returns true if A knows B, false otherwise. How can we solve the problem. 

Examples:  

Input:
MATRIX = { {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 0, 0}, {0, 0, 1, 0} }
Output: id = 2
Explanation: The person with ID 2 does not know anyone but everyone knows him

Input:
MATRIX = { {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 1, 0, 0}, {0, 0, 1, 0} }
Output: No celebrity
Explanation: There is no celebrity.

The Celebrity Problem uses Graph to arrive at a particular solution
Using graphs. Initialize indegree and outdegree of every vertex as 0. If A knows B, draw a directed edge from A to B, increase indegree of B and outdegree of A by 1. Construct all possible edges of the graph for every possible pair [i, j]. There are NC2 pairs. If a celebrity is present in the party, there will be one sink node in the graph with outdegree of zero and indegree of N-1. 

Follow the steps below to solve the problem:

Create two arrays indegree and outdegree, to store the indegree and outdegree
Run a nested loop, the outer loop from 0 to n and inner loop from 0 to n.
For every pair i, j check if i knows j then increase the outdegree of i and indegree of j.
For every pair i, j check if j knows i then increase the outdegree of j and indegree of i.
Run a loop from 0 to n and find the id where the indegree is n-1 and outdegree is 0.

// C++ program to find celebrity
#include <bits/stdc++.h>
#include <list>
using namespace std;
 
// Max # of persons in the party
#define N 8
 
// Person with 2 is celebrity
bool MATRIX[N][N] = { { 0, 0, 1, 0 },
                      { 0, 0, 1, 0 },
                      { 0, 0, 0, 0 },
                      { 0, 0, 1, 0 } };
 
bool knows(int a, int b) { return MATRIX[a][b]; }
 
// Returns -1 if celebrity
// is not present. If present,
// returns id (value from 0 to n-1).
int findCelebrity(int n)
{
    // the graph needs not be constructed
    // as the edges can be found by
    // using knows function
 
    // degree array;
    int indegree[n] = { 0 }, outdegree[n] = { 0 };
 
    // query for all edges
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            int x = knows(i, j);
 
            // set the degrees
            outdegree[i] += x;
            indegree[j] += x;
        }
    }
 
    // find a person with indegree n-1 and out degree 0
    for (int i = 0; i < n; i++)
        if (indegree[i] == n - 1 && outdegree[i] == 0)
            return i;
 
    return -1;
}
 
// Driver code
int main()
{
    int n = 4;
    int id = findCelebrity(n);
    id == -1 ? cout << "No celebrity"
             : cout << "Celebrity ID " << id;
    return 0;
}
Output
Celebrity ID 2
Time Complexity: O(N2), A nested loop is run traversing the array
Auxiliary Space: O(N), Since extra space of size N is required.

Using Recursion:
The problem can be solved using recursion. Say, if the ‘potential celebrity’ of N-1 persons is known, can the solution to N be found from it? A potential celebrity is one who is the only one left after eliminating n-1 people. n-1 people are eliminated with the following strategy: 

If A knows B, then A cannot be a celebrity. But B could be.
Else If B knows A, then B cannot be a celebrity. But A could be.
The above-mentioned approach uses Recursion to find the potential celebrity among n persons, that recursively calls n-1 persons, till the base case of 0 persons is reached. For 0 persons -1 is returned indicating that there are no possible celebrities since there are 0 people. In the ith stage of recursion, the ith person and (i-1)th person are compared to check if anyone of them knows the other. And using the above logic (in the bullet points) the potential celebrity is returned to the (i+1)th stage.

Once the recursive function returns an id. We check if this id does not know anybody else, but all others know this id. If this is true, then this id will be the celebrity.

Follow the steps below to solve the problem:

Create a recursive function that takes an integer n.
Check the base case, if the value of n is 0 then return -1.
Call the recursive function and get the ID of the potential celebrity from the first n-1 elements.
If the id is -1 then assign n as the potential celebrity and return the value.
If the potential  celebrity of first n-1 elements knows n-1 then return n-1, (0 based indexing)
If the celebrity of the first n-1 elements does not know n-1 then return id of the celebrity of n-1 elements, (0 based indexing)
Else return -1.
Create a wrapper function and check whether the id returned by the function is really the celebrity or not.

// C++ program to find celebrity
#include <bits/stdc++.h>
#include <list>
using namespace std;
 
// Max # of persons in the party
#define N 8
 
// Person with 2 is celebrity
bool MATRIX[N][N] = { { 0, 0, 1, 0 },
                      { 0, 0, 1, 0 },
                      { 0, 0, 0, 0 },
                      { 0, 0, 1, 0 } };
 
bool knows(int a, int b) { return MATRIX[a][b]; }
 
// Returns -1 if a 'potential celebrity'
// is not present. If present,
// returns id (value from 0 to n-1).
int findPotentialCelebrity(int n)
{
    // base case - when n reaches 0 , returns -1
    // since n represents the number of people,
    // 0 people implies no celebrity(= -1)
    if (n == 0)
        return -1;
 
    // find the celebrity with n-1
    // persons
    int id = findPotentialCelebrity(n - 1);
 
    // if there are no celebrities
    if (id == -1)
        return n - 1;
 
    // if the id knows the nth person
    // then the id cannot be a celebrity, but nth person
    // could be one
    else if (knows(id, n - 1)) {
        return n - 1;
    }
    // if the nth person knows the id,
    // then the nth person cannot be a celebrity and the id
    // could be one
    else if (knows(n - 1, id)) {
        return id;
    }
 
    // if there is no celebrity
    return -1;
}
 
// Returns -1 if celebrity
// is not present. If present,
// returns id (value from 0 to n-1).
// a wrapper over findCelebrity
int Celebrity(int n)
{
    // find the celebrity
    int id = findPotentialCelebrity(n);
 
    // check if the celebrity found
    // is really the celebrity
    if (id == -1)
        return id;
    else {
        int c1 = 0, c2 = 0;
 
        // check the id is really the
        // celebrity
        for (int i = 0; i < n; i++)
            if (i != id) {
                c1 += knows(id, i);
                c2 += knows(i, id);
            }
 
        // if the person is known to
        // everyone.
        if (c1 == 0 && c2 == n - 1)
            return id;
 
        return -1;
    }
}
 
// Driver code
int main()
{
    int n = 4;
    int id = Celebrity(n);
    id == -1 ? cout << "No celebrity"
             : cout << "Celebrity ID " << id;
    return 0;
}
Output
Celebrity ID 2
Time Complexity: O(N), The recursive function is called n times.
Auxiliary Space: O(1). 

Using Elimination Technique:
Some observations are based on elimination technique (Refer to Polya’s How to Solve It book). 

If A knows B, then A can’t be a celebrity. Discard A, and B may be celebrity.
If A doesn’t know B, then B can’t be a celebrity. Discard B, and A may be celebrity.
Repeat above two steps till there is only one person.
Ensure the remained person is a celebrity. (What is the need of this step?)

Follow the steps below to solve the problem:

Create a stack and push all the ids in the stack.
Run a loop while there are more than 1 element in the stack.
Pop the top two elements from the stack (represent them as A and B)
If A knows B, then A can’t be a celebrity and push B in the stack. Else if A doesn’t know B, then B can’t be a celebrity push A in the stack.
Assign the remaining element in the stack as the celebrity.
Run a loop from 0 to n-1 and find the count of persons who knows the celebrity and the number of people whom the celebrity knows.
If the count of persons who knows the celebrity is n-1 and the count of people whom the celebrity knows is 0 then return the id of the celebrity else return -1.

// C++ program to find celebrity
#include <bits/stdc++.h>
#include <list>
using namespace std;
 
// Max # of persons in the party
#define N 8
 
// Person with 2 is celebrity
bool MATRIX[N][N] = { { 0, 0, 1, 0 },
                      { 0, 0, 1, 0 },
                      { 0, 0, 0, 0 },
                      { 0, 0, 1, 0 } };
 
bool knows(int a, int b) { return MATRIX[a][b]; }
 
// Returns -1 if celebrity
// is not present. If present,
// returns id (value from 0 to n-1).
int findCelebrity(int n)
{
 
    stack<int> s;
 
    // Celebrity
    int C;
 
    // Push everybody to stack
    for (int i = 0; i < n; i++)
        s.push(i);
 
    // Extract top 2
 
    // Find a potential celebrity
    while (s.size() > 1) {
        int A = s.top();
        s.pop();
        int B = s.top();
        s.pop();
        if (knows(A, B)) {
            s.push(B);
        }
        else {
            s.push(A);
        }
    }
 
    // Potential candidate?
    C = s.top();
    s.pop();
 
    // Check if C is actually
    // a celebrity or not
    for (int i = 0; i < n; i++) {
        // If any person doesn't
        // know 'C' or 'C' doesn't
        // know any person, return -1
        if ((i != C) && (knows(C, i) || !knows(i, C)))
            return -1;
    }
 
    return C;
}
 
// Driver code
int main()
{
    int n = 4;
    int id = findCelebrity(n);
    id == -1 ? cout << "No celebrity"
             : cout << "Celebrity ID " << id;
    return 0;
}
Output
Celebrity ID 2
Time Complexity: O(N), The total number of comparisons is 3(N-1).
Auxiliary Space: O(N), n extra space is needed to store the stack.

Using Elimination Technique (Efficient):
The idea is to follow below to steps based on the above approach:

If A knows B, then A can’t be a celebrity. Discard A, and B may be celebrity.
If A doesn’t know B, then B can’t be a celebrity. Discard B, and A may be celebrity.
We will not use any extra space as will use spaces M[i][i] for storing whether i th person is a celebrity or not as these are by default 0, so if we find i th person is not a celebrity then we will mark M[i][i] as 1

Follow the steps below to solve the problem:

We will make a variable that will store the current row and start a loop from 0 to n-1 and if M[row][i] is 1 then mark M[row][row]=1 and update row = i and if M[row][i]=0 then mark M[i][i]=1.
After the loop we iterate on the diagonal of the matrix i.e M[i][i] where i->(0,n-1) there will be only one element in the diagonal whose value will be 0, when found iterate on all the rows from top to bottom with the column set to i  and if there is no 0 in that column then return i and if there are positive number of zeroes then return -1

#include <bits/stdc++.h>
using namespace std;
 
class Solution {
public:
    // Function to find if there is a celebrity in the party
    // or not.
    int celebrity(int M[4][4], int n)
    {
        // r=row number
        int r = 0;
        for (int i = 1; i < n; i++) {
            // checking if r th person knows i th person
            if (M[r][i] == 1) {
                M[r][r] = 1;
                r = i;
            }
            else {
                M[i][i] = 1;
            }
        }
        for (int i = 0; i < n; i++) {
            // checking if i th person can be a celebrity or
            // not
            if (M[i][i] == 0) {
                int flag = 0;
                // iterating in the i th column to check
                // whether everyone knows i th person or not
                for (int j = 0; j < n; j++) {
                    // checking if M[j][i] is not a diagonal
                    // element and if j th person knows i th
                    // person
                    if (j != i && M[j][i] == 0) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0)
                    return i;
            }
        }
        return -1;
    }
};
 
int main()
{
    int M[4][4] = { { 0, 0, 1, 0 },
                    { 0, 0, 1, 0 },
                    { 0, 0, 0, 0 },
                    { 0, 0, 1, 0 } };
    Solution ob;
    int a = ob.celebrity(M, 4);
    if (a == -1) {
        cout << "No Celebrity" << endl;
    }
    else {
        cout << "Celebrity ID " << a << endl;
    }
}
Output
Celebrity ID 2
Time Complexity: O(N), Number of iterations is 3 times i.e 3N so the time complexity is O(N) 
Auxiliary Space: O(1)

Arithmetic Expression evaluation	
-------------------------------------
The stack organization is very effective in evaluating arithmetic expressions. Expressions are usually represented in what is known as Infix notation, in which each operator is written between two operands (i.e., A + B). With this notation, we must distinguish between ( A + B )*C and A + ( B * C ) by using either parentheses or some operator-precedence convention. Thus, the order of operators and operands in an arithmetic expression does not uniquely determine the order in which the operations are to be performed. 

1. Polish notation (prefix notation) – 
It refers to the notation in which the operator is placed before its two operands. Here no parentheses are required, i.e., 

+AB 

2. Reverse Polish notation(postfix notation) – 
It refers to the analogous notation in which the operator is placed after its two operands. Again, no parentheses is required in Reverse Polish notation, i.e., 
 
AB+ 
Stack-organized computers are better suited for post-fix notation than the traditional infix notation. Thus, the infix notation must be converted to the postfix notation. The conversion from infix notation to postfix notation must take into consideration the operational hierarchy. 
There are 3 levels of precedence for 5 binary operators as given below: 
 
Highest: Exponentiation (^)
Next highest: Multiplication (*) and division (/)
Lowest: Addition (+) and Subtraction (-)

For example – 

Infix notation: (A-B)*[C/(D+E)+F]
Post-fix notation: AB- CDE +/F +* 
Here, we first perform the arithmetic inside the parentheses (A-B) and (D+E). The division of C/(D+E) must be done prior to the addition with F. After that multiply the two terms inside the parentheses and bracket. 

Now we need to calculate the value of these arithmetic operations by using a stack. 

The procedure for getting the result is: 
 
Convert the expression in Reverse Polish notation( post-fix notation). 
Push the operands into the stack in the order they appear. 
When any operator encounters then pop two topmost operands for executing the operation. 
After execution push the result obtained into the stack. 
After the complete execution of expression, the final result remains on the top of the stack. 
 
For example – 
Infix notation: (2+4) * (4+6)
Post-fix notation: 2 4 + 4 6 + *
Result: 60 

Evaluation of Postfix expression	
------------------------------------------
The Postfix notation is used to represent algebraic expressions. The expressions written in postfix form are evaluated faster compared to infix notation as parenthesis is not required in postfix.

Example: 

Input: str = “2 3 1 * + 9 -“
Output: -4
Explanation: 

Scan 2, it’s a number, so push it to stack. Stack contains ‘2’ 
Scan 3, again a number, push it to stack, stack now contains ‘2 3’ (from bottom to top) 
Scan 1, again a number, push it to stack, stack now contains ‘2 3 1’ 
Scan *, it’s an operator, pop two operands from stack, apply the * operator on operands, we get 3*1 which results in 3. We push the result 3 to stack. The stack now becomes ‘2 3’. 
Scan +, it’s an operator, pop two operands from stack, apply the + operator on operands, we get 3 + 2 which results in 5. We push the result 5 to stack. The stack now becomes ‘5’. 
Scan 9, it’s a number, so we push it to the stack. The stack now becomes ‘5 9’. 
Scan -, it’s an operator, pop two operands from stack, apply the – operator on operands, we get 5 – 9 which results in -4. We push the result -4 to the stack. The stack now becomes ‘-4’. 
There are no more elements to scan, we return the top element from the stack (which is the only element left in a stack).
Input: str = “100 200 + 2 / 5 * 7 +”
Output: 757

Create a stack to store operands (or values). 
Scan the given expression from left to right and do the following for every scanned element. 
If the element is a number, push it into the stack 
If the element is an operator, pop operands for the operator from the stack. Evaluate the operator and push the result back to the stack 
When the expression is ended, the number in the stack is the final answer                                                                                                            
Below is the implementation of the above approach:


// C++ program to evaluate value of a postfix expression
#include <iostream>
#include <string.h>
 
using namespace std;
 
// Stack type
struct Stack
{
    int top;
    unsigned capacity;
    int* array;
};
 
// Stack Operations
struct Stack* createStack( unsigned capacity )
{
    struct Stack* stack = (struct Stack*) malloc(sizeof(struct Stack));
 
    if (!stack) return NULL;
 
    stack->top = -1;
    stack->capacity = capacity;
    stack->array = (int*) malloc(stack->capacity * sizeof(int));
 
    if (!stack->array) return NULL;
 
    return stack;
}
 
int isEmpty(struct Stack* stack)
{
    return stack->top == -1 ;
}
 
char peek(struct Stack* stack)
{
    return stack->array[stack->top];
}
 
char pop(struct Stack* stack)
{
    if (!isEmpty(stack))
        return stack->array[stack->top--] ;
    return '$';
}
 
void push(struct Stack* stack, char op)
{
    stack->array[++stack->top] = op;
}
 
 
// The main function that returns value of a given postfix expression
int evaluatePostfix(char* exp)
{
    // Create a stack of capacity equal to expression size
    struct Stack* stack = createStack(strlen(exp));
    int i;
 
    // See if stack was created successfully
    if (!stack) return -1;
 
    // Scan all characters one by one
    for (i = 0; exp[i]; ++i)
    {
        // If the scanned character is an operand (number here),
        // push it to the stack.
        if (isdigit(exp[i]))
            push(stack, exp[i] - '0');
 
        // If the scanned character is an operator, pop two
        // elements from stack apply the operator
        else
        {
            int val1 = pop(stack);
            int val2 = pop(stack);
            switch (exp[i])
            {
            case '+': push(stack, val2 + val1); break;
            case '-': push(stack, val2 - val1); break;
            case '*': push(stack, val2 * val1); break;
            case '/': push(stack, val2/val1); break;
            }
        }
    }
    return pop(stack);
}
 
// Driver program to test above functions
int main()
{
    char exp[] = "231*+9-";
    cout<<"postfix evaluation: "<< evaluatePostfix(exp);
    return 0;
}
Output
postfix evaluation: -4
Time Complexity: O(N) 
Auxiliary Space: O(N)

There are the following limitations of the above implementation. 

It supports only 4 binary operators ‘+’, ‘*’, ‘-‘ and ‘/’. It can be extended for more operators by adding more switch cases. 
The allowed operands are only single-digit operands. The program can be extended for multiple digits by adding a separator-like space between all elements (operators and operands) of the given expression. 

Below given is the extended program which allows operands to have multiple digits. 


// C++ program to evaluate value of a postfix expression having multiple digit operands
#include <bits/stdc++.h>
using namespace std;
 
// Stack type
class Stack
{
    public:
    int top;
    unsigned capacity;
    int* array;
};
 
// Stack Operations
Stack* createStack( unsigned capacity )
{
    Stack* stack = new Stack();
 
    if (!stack) return NULL;
 
    stack->top = -1;
    stack->capacity = capacity;
    stack->array = new int[(stack->capacity * sizeof(int))];
 
    if (!stack->array) return NULL;
 
    return stack;
}
 
int isEmpty(Stack* stack)
{
    return stack->top == -1 ;
}
 
int peek(Stack* stack)
{
    return stack->array[stack->top];
}
 
int pop(Stack* stack)
{
    if (!isEmpty(stack))
        return stack->array[stack->top--] ;
    return '$';
}
 
void push(Stack* stack,int op)
{
    stack->array[++stack->top] = op;
}
 
// The main function that returns value
// of a given postfix expression
int evaluatePostfix(char* exp)
{
    // Create a stack of capacity equal to expression size
    Stack* stack = createStack(strlen(exp));
    int i;
 
    // See if stack was created successfully
    if (!stack) return -1;
 
    // Scan all characters one by one
    for (i = 0; exp[i]; ++i)
    {
        //if the character is blank space then continue
        if(exp[i] == ' ')continue;
         
        // If the scanned character is an
        // operand (number here),extract the full number
        // Push it to the stack.
        else if (isdigit(exp[i]))
        {
            int num=0;
             
            //extract full number
            while(isdigit(exp[i]))
            {
            num = num * 10 + (int)(exp[i] - '0');
                i++;
            }
            i--;
             
            //push the element in the stack
            push(stack,num);
        }
         
        // If the scanned character is an operator, pop two
        // elements from stack apply the operator
        else
        {
            int val1 = pop(stack);
            int val2 = pop(stack);
             
            switch (exp[i])
            {
            case '+': push(stack, val2 + val1); break;
            case '-': push(stack, val2 - val1); break;
            case '*': push(stack, val2 * val1); break;
            case '/': push(stack, val2/val1); break;
             
            }
        }
    }
    return pop(stack);
}
 
// Driver code
int main()
{
    char exp[] = "100 200 + 2 / 5 * 7 +";
    cout << evaluatePostfix(exp);
    return 0;
}
 
Output
757
Time Complexity: O(N) 
Auxiliary Space: O(N)

Implement a method to insert an element at its bottom without Using any other data structure.	
------------------------------------------------------------------------------------------------
Given a stack S and an integer N, the task is to insert N at the bottom of the stack.

Examples:

Input: N = 7
S = 1 <- (Top)
    2
    3
    4
    5
Output: 1 2 3 4 5 7

Input: N = 17
S = 1 <- (Top)
    12
    34
    47
    15
Output: 1 12 34 47 15 17

Naive Approach: The simplest approach would be to create another stack. Follow the steps below to solve the problem:

Initialize a stack, say temp.
Keep popping from the given stack S and pushing the popped elements into temp, until the stack S becomes empty.
Push N into the stack S.
Now, keep popping from the stacktemp and push the popped elements into the stack S, until the stack temp becomes empty.

// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;
 
// Function to insert an element at the bottom of a given stack
void insertToBottom(stack<int> S, int N)
{
    // Temporary stack
    stack<int> temp;
 
    // Iterate until S becomes empty
    while (!S.empty()) {
 
        // Push the top element of S into the stack temp
        temp.push(S.top());
 
        // Pop the top element of S
        S.pop();
    }
 
    // Push N into the stack S
    S.push(N);
 
    // Iterate until temp becomes empty
    while (!temp.empty()) {
 
        // Push the top element of temp into the stack S
        S.push(temp.top());
 
        // Pop the top element of temp
        temp.pop();
    }
 
    // Print the elements of S
    while (!S.empty()) {
        cout << S.top() << " ";
        S.pop();
    }
}
 
// Driver Code
int main()
{
    // Input
    stack<int> S;
    S.push(5);
    S.push(4);
    S.push(3);
    S.push(2);
    S.push(1);
 
    int N = 7;
 
    insertToBottom(S, N);
 
    return 0;
}
Output: 
1 2 3 4 5 7
Time Complexity: O(N)
Auxiliary Space: O(N)

Efficient Approach: Instead of using a temporary stack, the implicit stack can be used through recursion. Follow the steps below to solve the problem: 

Define a recursion function that accepts the stack S and an integer as parameters and returns a stack.
Base case to be considered is if the stack is empty. For this scenario, push N into the stack and return it.
Otherwise, remove the top element of S and store it in a variable, say X.
Recurse again using the new stack
Push X into S.

// C++ program for the above approach
#include <bits/stdc++.h>
using namespace std;
 
// Recursive function to use implicit stack
// to insert an element at the bottom of stack
stack<int> recur(stack<int> S, int N)
{
    // If stack is empty
    if (S.empty())
        S.push(N);
 
    else {
 
        // Stores the top element
        int X = S.top();
 
        // Pop the top element
        S.pop();
 
        // Recurse with remaining elements
        S = recur(S, N);
 
        // Push the previous top element again
        S.push(X);
    }
    return S;
}
 
// Function to insert an element at the bottom of stack
void insertToBottom(
    stack<int> S, int N)
{
 
    // Recursively insert N at the bottom of S
    S = recur(S, N);
 
    // Print the stack S
    while (!S.empty()) {
        cout << S.top() << " ";
        S.pop();
    }
}
 
// Driver Code
int main()
{
    // Input
    stack<int> S;
    S.push(5);
    S.push(4);
    S.push(3);
    S.push(2);
    S.push(1);
 
    int N = 7;
 
    insertToBottom(S, N);
 
    return 0;
}
Output: 
1 2 3 4 5 7
Time Complexity: O(N), where N is the total number of elements in the stack. 
Auxiliary Space: O(N) 

Reverse a stack using recursion	
------------------------------------------
Write a program to reverse a stack using recursion, without using any loop.

Example: 

Input: elements present in stack from top to bottom 1 2 3 4 
Output: 4 3 2 1 

Input: elements present in stack from top to bottom 1 2 3
Output: 3 2 1


Recommended Problem
Reverse a Stack
Recursion
Stack
Solve Problem
Submission count: 12.9K
Reverse a stack using Recursion
The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one at the bottom of the stack. 

Illustration: 

Below is the illustration of the above approach

Let given stack be
       1        
       2
       3
       4
After all calls of reverse,  4 will be passed to function insert at bottom, after that 4 will pushed to the stack when stack is empty
      4       
Then 3 will be passed to function insert at bottom , it will check if the stack is empty or not if not then pop all the elements back and insert 3 and then push other elements back.                                                                                   
      4       
      3
Then 2 will be passed to function insert at bottom , it will check if the stack is empty or not if not then pop all the elements back and insert 2 and then push other elements back.
      4       
      3
      2
Then 1 will be passed to function insert at bottom , it will check if the stack is empty or not if not then pop all the elements back and insert 1 and then push other elements back.
 
      4       
      3
      2
      1
Follow the steps mentioned below to implement the idea:

Create a stack and push all the elements in it.
Call reverse(), which will pop all the elements from the stack and pass the popped element to function insert_at_bottom()
Whenever insert_at_bottom() is called it will insert the passed element at the bottom of the stack.
Print the stack                             

// C++ code to reverse a stack using recursion
#include <bits/stdc++.h>
using namespace std;
 
// Below is a recursive function
// that inserts an element
// at the bottom of a stack.
void insert_at_bottom(stack<int>& st, int x)
{
 
    if (st.size() == 0) {
        st.push(x);
    }
    else {
 
        // All items are held in Function Call
        // Stack until we reach end of the stack
        // When the stack becomes empty, the
        // st.size() becomes 0, the above if
        // part is executed and the item is
        // inserted at the bottom
 
        int a = st.top();
        st.pop();
        insert_at_bottom(st, x);
 
        // push allthe items held in
        // Function Call Stack
        // once the item is inserted
        // at the bottom
        st.push(a);
    }
}
 
// Below is the function that
// reverses the given stack using
// insert_at_bottom()
void reverse(stack<int>& st)
{
    if (st.size() > 0) {
 
        // Hold all items in Function Call Stack until we reach end of the stack
        int x = st.top();
        st.pop();
        reverse(st);
 
// Insert all the items held in Function Call Stack one by one from the bottomto top. Every item is inserted at the bottom
        insert_at_bottom(st, x);
    }
    return;
}
 
// Driver Code
int main()
{
    stack<int> st, st2;
    // push elements into
    // the stack
    for (int i = 1; i <= 4; i++) {
        st.push(i);
    }
 
    st2 = st;

    cout << "Original Stack" << endl;
    // printing the stack after reversal
    while (!st2.empty()) {
        cout << st2.top() << " ";
        st2.pop();
    }
    cout<<endl;
   
    // function to reverse
    // the stack
    reverse(st);
    cout << "Reversed Stack" << endl;
    // printing the stack after reversal
    while (!st.empty()) {
        cout << st.top() << " ";
        st.pop();
    }
    return 0;
}
Output
Original Stack
1 2 3 4 
Reversed Stack
1 2 3 4 
Time Complexity: O(N2). 
Auxiliary Space: O(N) use of Stack 

Sort a Stack using recursion	
-------------------------------------
Given a stack, the task is to sort it using recursion.

Example: 

Input: elements present in stack from top to bottom -3 14 18 -5 30
Output: 30 18 14 -3 -5
Explanation: The given stack is sorted know 30 > 18 > 14 > -3 > -5

Input: elements present in stack from top to bottom 1 2 3
Output: 3 2 1
Explanation: The given stack is sorted know 3 > 2 > 1

Using Stack
The idea of the solution is to hold all values in Function Call Stack until the stack becomes empty. When the stack becomes empty, insert all held items one by one in sorted order. and then print the stack

Illustration: 

Let given stack be
         -3         
         14
         18
         -5
         30
Let us illustrate sorting of stack using the above example:
First pop all the elements from the stack and store popped element in the variable ‘temp’. After popping all the elements function’s stack frame will look like this:
 
-3	stack frame 1 
14	stack frame 2
18	stack frame 3
-5	stack frame 4
30	stack frame 5
Now stack is empty so function insert in sorted order is called and it inserts 30 (from stack frame 5) at the bottom of the stack. Now stack looks like the below:
         30         
Now next element  -5 (from stack frame 4) is picked. Since -5 < 30, -5 is inserted at the bottom of the stack. Now stack becomes: 
         30         
         -5
Next 18 (from stack frame 3) is picked. Since 18 < 30, 18 is inserted below 30. Now stack becomes:
         30         
         18
         -5
Next 14 (from stack frame 2) is picked. Since 14 < 30 and 14 < 18, it is inserted below 18. Now stack becomes: 
         30
         18
         14
         -5         
Now -3 (from stack frame 1) is picked, as -3 < 30 and -3 < 18 and -3 < 14, it is inserted below 14. Now stack becomes:
         30          
         18
         14
         -3
         -5
Follow the steps mentioned below to implement the idea:

Create a stack and push all the elements in it.
Call sortStack(), which will pop an element from the stack and pass the popped element to function sortInserted(), then it will keep calling itself until the stack is empty.
Whenever sortInserted() is called it will insert the passed element in stack in sorted order.
Print the stack                             

// C++ program to sort a stack using recursion
#include <iostream>
using namespace std;
 
// Stack is represented using linked list
struct stack {
    int data;
    struct stack* next;
};
 
// Utility function to initialize stack
void initStack(struct stack** s) { *s = NULL; }
 
// Utility function to check if stack is empty
int isEmpty(struct stack* s)
{
    if (s == NULL)
        return 1;
    return 0;
}
 
// Utility function to push an item to stack
void push(struct stack** s, int x)
{
    struct stack* p = (struct stack*)malloc(sizeof(*p));
 
    if (p == NULL) {
        fprintf(stderr, "Memory allocation failed.\n");
        return;
    }
 
    p->data = x;
    p->next = *s;
    *s = p;
}
 
// Utility function to remove an item from stack
int pop(struct stack** s)
{
    int x;
    struct stack* temp;
 
    x = (*s)->data;
    temp = *s;
    (*s) = (*s)->next;
    free(temp);
 
    return x;
}
 
// Function to find top item
int top(struct stack* s) { return (s->data); }
 
// Recursive function to insert an item x in sorted way
void sortedInsert(struct stack** s, int x)
{
    // Base case: Either stack is empty or newly inserted
    // item is greater than top (more than all existing)
    if (isEmpty(*s) or x > top(*s)) {
        push(s, x);
        return;
    }
 
    // If top is greater, remove the top item and recur
    int temp = pop(s);
    sortedInsert(s, x);
 
    // Put back the top item removed earlier
    push(s, temp);
}
 
// Function to sort stack
void sortStack(struct stack** s)
{
    // If stack is not empty
    if (!isEmpty(*s)) {
        // Remove the top item
        int x = pop(s);
 
        // Sort remaining stack
        sortStack(s);
 
        // Push the top item back in sorted stack
        sortedInsert(s, x);
    }
}
 
// Utility function to print contents of stack
void printStack(struct stack* s)
{
    while (s) {
        cout << s->data << " ";
        s = s->next;
    }
    cout << "\n";
}
 
// Driver code
int main(void)
{
    struct stack* top;
 
    initStack(&top);
    push(&top, 30);
    push(&top, -5);
    push(&top, 18);
    push(&top, 14);
    push(&top, -3);
 
    cout << "Stack elements before sorting:\n";
    printStack(top);
 
    sortStack(&top);
    cout << "\n";
 
    cout << "Stack elements after sorting:\n";
    printStack(top);
 
    return 0;
}
 
Output
Stack elements before sorting:
-3 14 18 -5 30 

Stack elements after sorting:
30 18 14 -3 -5 
Time Complexity: O(N2). 
Auxiliary Space: O(N) use of Stack

Merge Overlapping Intervals	
----------------------------------
Given a set of time intervals in any order, merge all overlapping intervals into one and output the result which should have only mutually exclusive intervals.

Example:

Input: Intervals = {{1,3},{2,4},{6,8},{9,10}}
Output: {{1, 4}, {6, 8}, {9, 10}}
Explanation: Given intervals: [1,3],[2,4],[6,8],[9,10], we have only two overlapping intervals here,[1,3] and [2,4]. Therefore we will merge these two and return [1,4],[6,8], [9,10].

Input: Intervals = {{6,8},{1,9},{2,4},{4,7}}
Output: {{1, 9}} 

Using Nested Loop
A simple approach is to start from the first interval and compare it with all other intervals for overlapping, if it overlaps with any other interval, then remove the other interval from the list and merge the other into the first interval. Repeat the same steps for the remaining intervals after the first. This approach cannot be implemented in better than O(n^2) time.

Merge Overlapping Intervals Optimized Approach
The idea to solve this problem is, first sort the intervals according to the starting time. Once we have the sorted intervals, we can combine all intervals in a linear traversal. The idea is, in sorted array of intervals, if interval[i] doesn’t overlap with interval[i-1], then interval[i+1] cannot overlap with interval[i-1] because starting time of interval[i+1] must be greater than or equal to interval[i].

Follow the steps mentioned below to implement the approach:

Sort the intervals based on the increasing order of starting time.
Push the first interval into a stack.
For each interval do the following:
If the current interval does not overlap with the top of the stack then, push the current interval into the stack.
If the current interval overlap with the top of the stack then, update the stack top with the ending time of the current interval.
The end stack contains the merged intervals. 

// A C++ program for merging overlapping intervals
#include <bits/stdc++.h>
using namespace std;
 
// An interval has start time and end time
struct Interval {
    int start, end;
};
 
// Compares two intervals according to their starting time.
// This is needed for sorting the intervals using library
// function std::sort().
bool compareInterval(Interval i1, Interval i2)
{
    return (i1.start < i2.start);
}
 
// The main function that takes a set of intervals, merges
// overlapping intervals and prints the result
void mergeIntervals(Interval arr[], int n)
{
    // Test if the given set has at least one interval
    if (n <= 0)
        return;
 
    // Create an empty stack of intervals
    stack<Interval> s;
 
    // sort the intervals in increasing order of start time
    sort(arr, arr + n, compareInterval);
 
    // push the first interval to stack
    s.push(arr[0]);
 
    // Start from the next interval and merge if necessary
    for (int i = 1; i < n; i++) {
        // get interval from stack top
        Interval top = s.top();
 
        // if current interval is not overlapping with stack
        // top, push it to the stack
        if (top.end < arr[i].start)
            s.push(arr[i]);
 
        // Otherwise update the ending time of top if ending
        // of current interval is more
        else if (top.end < arr[i].end) {
            top.end = arr[i].end;
            s.pop();
            s.push(top);
        }
    }
 
    // Print contents of stack
    cout << "\n The Merged Intervals are: ";
    while (!s.empty()) {
        Interval t = s.top();
        cout << "[" << t.start << "," << t.end << "] ";
        s.pop();
    }
    return;
}
 
// Driver program
int main()
{
    Interval arr[]
        = { { 6, 8 }, { 1, 9 }, { 2, 4 }, { 4, 7 } };
    int n = sizeof(arr) / sizeof(arr[0]);
    mergeIntervals(arr, n);
    return 0;
}
Output
The Merged Intervals are: [1,9] 
Time complexity: O(N*log(N))
Auxiliary Space: O(N)

Space Optimized Approach:

The above solution requires O(n) extra space for the stack. We can avoid the use of extra space by doing merge operations in place. Below are detailed steps. 

Follow the steps mentioned below to implement the approach:

Sort all intervals in increasing order of start time.
Traverse sorted intervals starting from the first interval, 
Do the following for every interval.
If the current interval is not the first interval and it overlaps with the previous interval,
then merge it with the previous interval. Keep doing it while the interval overlaps with the previous one.         
Otherwise, Add the current interval to the output list of intervals.

// C++ program to merge overlapping Intervals in
// O(n Log n) time and O(1) extra space.
#include <bits/stdc++.h>
using namespace std;
 
// An Interval
struct Interval {
    int s, e;
};
 
// Function used in sort
bool mycomp(Interval a, Interval b) { return a.s < b.s; }
 
void mergeIntervals(Interval arr[], int n)
{
    // Sort Intervals in increasing order of
    // start time
    sort(arr, arr + n, mycomp);
 
    int index = 0; // Stores index of last element
    // in output array (modified arr[])
 
    // Traverse all input Intervals
    for (int i = 1; i < n; i++) {
        // If this is not first Interval and overlaps
        // with the previous one
        if (arr[index].e >= arr[i].s) {
            // Merge previous and current Intervals
            arr[index].e = max(arr[index].e, arr[i].e);
        }
        else {
            index++;
            arr[index] = arr[i];
        }
    }
 
    // Now arr[0..index-1] stores the merged Intervals
    cout << "\n The Merged Intervals are: ";
    for (int i = 0; i <= index; i++)
        cout << "[" << arr[i].s << ", " << arr[i].e << "] ";
}
 
// Driver program
int main()
{
    Interval arr[]
        = { { 6, 8 }, { 1, 9 }, { 2, 4 }, { 4, 7 } };
    int n = sizeof(arr) / sizeof(arr[0]);
    mergeIntervals(arr, n);
    return 0;
}
 
Output
The Merged Intervals are: [1, 9] 
Time Complexity: O(N*log(N))
Auxiliary Space Complexity: O(1)

Largest rectangular Area in Histogram	
-------------------------------------------
Find the largest rectangular area possible in a given histogram where the largest rectangle can be made of a number of contiguous bars whose heights are given in an array. For simplicity, assume that all bars have the same width and the width is 1 unit. 

Example: 

Input: histogram = {6, 2, 5, 4, 5, 1, 6}
 











Output: 12

Input: histogram = {3, 5, 1, 7, 5, 9}
Output: 15

To solve the problem follow the below idea:

For every bar ‘x’, we calculate the area with ‘x’ as the smallest bar in the rectangle. If we calculate the such area for every bar ‘x’ and find the maximum of all areas, our task is done. 

How to calculate the area with ‘x’ as the smallest bar? 

We need to know the index of the first smaller (smaller than ‘x’) bar on the left of ‘x’ and the index of the first smaller bar on the right of ‘x’. Let us call these indexes as ‘left index’ and ‘right index’ respectively. We traverse all bars from left to right and maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from the stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as the smallest bar. 

How do we get the left and right indexes of the popped bar?

The current index tells us the right index and the index of the previous item in the stack is the left index

Follow the given steps to solve the problem:

Create an empty stack.
Start from the first bar, and do the following for every bar hist[i] where ‘i‘ varies from 0 to n-1
If the stack is empty or hist[i] is higher than the bar at top of the stack, then push ‘i‘ to stack. 
If this bar is smaller than the top of the stack, then keep removing the top of the stack while the top of the stack is greater. 
Let the removed bar be hist[tp]. Calculate the area of the rectangle with hist[tp] as the smallest bar. 
For hist[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i‘ (current index).
If the stack is not empty, then one by one remove all bars from the stack and do step (2.2 and 2.3) for every removed bar

// C++ program to find maximum rectangular area in
// linear time
#include <bits/stdc++.h>
using namespace std;
  
// The main function to find the maximum rectangular
// area under given histogram with n bars
int getMaxArea(int hist[], int n)
{
    // Create an empty stack. The stack holds indexes
    // of hist[] array. The bars stored in stack are
    // always in increasing order of their heights.
    stack<int> s;
  
    int max_area = 0; // Initialize max area
    int tp; // To store top of stack
    int area_with_top; // To store area with top bar
                       // as the smallest bar
  
    // Run through all bars of given histogram
    int i = 0;
    while (i < n) {
        // If this bar is higher than the bar on top
        // stack, push it to stack
        if (s.empty() || hist[s.top()] <= hist[i])
            s.push(i++);
  
        // If this bar is lower than top of stack,
        // then calculate area of rectangle with stack
        // top as the smallest (or minimum height) bar.
        // 'i' is 'right index' for the top and element
        // before top in stack is 'left index'
        else {
            tp = s.top(); // store the top index
            s.pop(); // pop the top
  
            // Calculate the area with hist[tp] stack
            // as smallest bar
            area_with_top
                = hist[tp]
                  * (s.empty() ? i : i - s.top() - 1);
  
            // update max area, if needed
            if (max_area < area_with_top)
                max_area = area_with_top;
        }
    }
  
    // Now pop the remaining bars from stack and calculate
    // area with every popped bar as the smallest bar
    while (s.empty() == false) {
        tp = s.top();
        s.pop();
        area_with_top
            = hist[tp] * (s.empty() ? i : i - s.top() - 1);
  
        if (max_area < area_with_top)
            max_area = area_with_top;
    }
  
    return max_area;
}
  
// Driver code
int main()
{
    int hist[] = { 6, 2, 5, 4, 5, 1, 6 };
    int n = sizeof(hist) / sizeof(hist[0]);
  
    // Function call
    cout << "Maximum area is " << getMaxArea(hist, n);
    return 0;
}
Output
Maximum area is 12
Time Complexity: O(N), Since every bar is pushed and popped only once
Auxiliary Space: O(N)

Largest Rectangular Area in a Histogram by finding the next and the previous smaller element:
To solve the problem follow the below idea:

Find the previous and the next smaller element for every element of the histogram, as this would help to calculate the length of the subarray in which this current element is the minimum element. So we can create a rectangle of size (current element * length of the subarray) using this element. Take the maximum of all such rectangles.

Follow the given steps to solve the problem:

First, we will take two arrays left_smaller[] and right_smaller[] and initialize them with -1 and n respectively
For every element, we will store the index of the previous smaller and next smaller element in left_smaller[] and right_smaller[] arrays respectively
Now for every element, we will calculate the area by taking this ith element as the smallest in the range left_smaller[i] and right_smaller[i] and multiplying it with the difference of left_smaller[i] and right_smaller[i]
We can find the maximum of all the areas calculated in step 3 to get the desired maximum area

// C++ code for the above approach
  
#include <bits/stdc++.h>
using namespace std;
  
// Function to find largest rectangular area possible in a
// given histogram.
int getMaxArea(int arr[], int n)
{
    // Your code here
    // we create an empty stack here.
    stack<int> s;
    // we push -1 to the stack because for some elements
    // there will be no previous smaller element in the
    // array and we can store -1 as the index for previous
    // smaller.
    s.push(-1);
    int area = arr[0];
    int i = 0;
    // We declare left_smaller and right_smaller array of
    // size n and initialize them with -1 and n as their
    // default value. left_smaller[i] will store the index
    // of previous smaller element for ith element of the
    // array. right_smaller[i] will store the index of next
    // smaller element for ith element of the array.
    vector<int> left_smaller(n, -1), right_smaller(n, n);
    while (i < n) {
        while (!s.empty() && s.top() != -1
               && arr[s.top()] > arr[i]) {
            // if the current element is smaller than
            // element with index stored on the top of stack
            // then, we pop the top element and store the
            // current element index as the right_smaller
            // for the popped element.
            right_smaller[s.top()] = i;
            s.pop();
        }
        if (i > 0 && arr[i] == arr[i - 1]) {
            // we use this condition to avoid the
            // unnecessary loop to find the left_smaller.
            // since the previous element is same as current
            // element, the left_smaller will always be the
            // same for both.
            left_smaller[i] = left_smaller[i - 1];
        }
        else {
            // Element with the index stored on the top of
            // the stack is always smaller than the current
            // element. Therefore the left_smaller[i] will
            // always be s.top().
            left_smaller[i] = s.top();
        }
        s.push(i);
        i++;
    }
    for (int j = 0; j < n; j++) {
        // here we find area with every element as the
        // smallest element in their range and compare it
        // with the previous area.
        // in this way we get our max Area form this.
        area = max(area, arr[j]
                             * (right_smaller[j]
                                - left_smaller[j] - 1));
    }
    return area;
}
  
// Driver code
int main()
{
    int hist[] = { 6, 2, 5, 4, 5, 1, 6 };
    int n = sizeof(hist) / sizeof(hist[0]);
  
    // Function call
    cout << "maxArea = " << getMaxArea(hist, n) << endl;
    return 0;
}
  
Output
maxArea = 12
Time Complexity: O(N)
Auxiliary Space: O(N)

Length of the Longest Valid Substring	
---------------------------------------------
Given a string consisting of opening and closing parenthesis, find the length of the longest valid parenthesis substring.

Examples: 

Input : ((()
Output : 2
Explanation : ()

Input: )()())
Output : 4
Explanation: ()() 

Input:  ()(()))))
Output: 6
Explanation:  ()(())

A Simple Approach is to find all the substrings of given string. For every string, check if it is a valid string or not. If valid and length is more than maximum length so far, then update maximum length. We can check whether a substring is valid or not in linear time using a stack (See this for details). Time complexity of this solution is O(n2).
An Efficient Solution can solve this problem in O(n) time. The idea is to store indexes of previous starting brackets in a stack. The first element of the stack is a special element that provides index before the beginning of valid substring (base for next valid string). 

1) Create an empty stack and push -1 to it. 
   The first element of the stack is used 
   to provide a base for the next valid string. 

2) Initialize result as 0.

3) If the character is '(' i.e. str[i] == '('), 
   push index'i' to the stack. 
   
2) Else (if the character is ')')
   a) Pop an item from the stack (Most of the 
      time an opening bracket)
   b) If the stack is not empty, then find the
      length of current valid substring by taking 
      the difference between the current index and
      top of the stack. If current length is more 
      than the result, then update the result.
   c) If the stack is empty, push the current index
      as a base for the next valid substring.

3) Return result.

// C++ program to find length of the
// longest valid substring
#include <bits/stdc++.h>
using namespace std;
 
int findMaxLen(string str)
{
    int n = str.length();
 
    // Create a stack and push -1 as
    // initial index to it.
    stack<int> stk;
    stk.push(-1);
 
    // Initialize result
    int result = 0;
 
    // Traverse all characters of given string
    for (int i = 0; i < n; i++)
    {
        // If opening bracket, push index of it
        if (str[i] == '(')
            stk.push(i);
         
        // If closing bracket, i.e.,str[i] = ')'
        else
        {
            // Pop the previous opening
            // bracket's index
            if (!stk.empty())
            {
                stk.pop();
            }
             
            // Check if this length formed with base of
            // current valid substring is more than max
            // so far
            if (!stk.empty())
                result = max(result, i - stk.top());
 
            // If stack is empty. push current index as
            // base for next valid substring (if any)
            else
                stk.push(i);
        }
    }
 
    return result;
}
 
// Driver code
int main()
{
    string str = "((()()";
   
    // Function call
    cout << findMaxLen(str) << endl;
 
    str = "()(()))))";
   
    // Function call
    cout << findMaxLen(str) << endl;
 
    return 0;
}

Output
4
6
 

Explanation with example: 

Input: str = "(()()"

Initialize result as 0 and stack with one item -1.

For i = 0, str[0] = '(', we push 0 in stack

For i = 1, str[1] = '(', we push 1 in stack

For i = 2, str[2] = ')', currently stack has 
[-1, 0, 1], we pop from the stack and the stack
now is [-1, 0] and length of current valid substring 
becomes 2 (we get this 2 by subtracting stack top from 
current index).

Since the current length is more than the current result, 
we update the result.

For i = 3, str[3] = '(', we push again, stack is [-1, 0, 3].
For i = 4, str[4] = ')', we pop from the stack, stack 
becomes [-1, 0] and length of current valid substring 
becomes 4 (we get this 4 by subtracting stack top from 
current index). 
Since current length is more than current result,
we update result. 
 

Another Efficient Approach can solve the problem in O(n) time. The idea is to maintain an array that stores the length of the longest valid substring ending at that index. We iterate through the array and return the maximum value.

1) Create an array longest of length n (size of the input
   string) initialized to zero.
   The array will store the length of the longest valid 
   substring ending at that index.

2) Initialize result as 0.

3) Iterate through the string from second character
   a) If the character is '(' set longest[i]=0 as no 
      valid sub-string will end with '('.
   b) Else
      i) if s[i-1] = '('
            set longest[i] = longest[i-2] + 2
      ii) else
            set longest[i] = longest[i-1] + 2 + 
            longest[i-longest[i-1]-2]

4) In each iteration update result as the maximum of 
   result and longest[i]

5) Return result.
 
// C++ program to find length of the longest valid
// substring
#include <bits/stdc++.h>
using namespace std;
 
int findMaxLen(string s)
{
    if (s.length() <= 1)
        return 0;
 
    // Initialize curMax to zero
    int curMax = 0;
 
    vector<int> longest(s.size(), 0);
 
    // Iterate over the string starting from second index
    for (int i = 1; i < s.length(); i++)
    {
        if (s[i] == ')' && i - longest[i - 1] - 1 >= 0
            && s[i - longest[i - 1] - 1] == '(')
        {
            longest[i]
                = longest[i - 1] + 2
                  + ((i - longest[i - 1] - 2 >= 0)
                  ? longest[i - longest[i - 1] - 2]
                  : 0);
            curMax = max(longest[i], curMax);
        }
    }
    return curMax;
}
 
// Driver code
int main()
{
    string str = "((()()";
   
    // Function call
    cout << findMaxLen(str) << endl;
 
    str = "()(()))))";
   
    // Function call
    cout << findMaxLen(str) << endl;
 
    return 0;
}
Output
4
6
Thanks to Gaurav Ahirwar and Ekta Goel for suggesting above approach.

Another approach in O(1) auxiliary space and O(N) Time complexity: 

The idea to solve this problem is to traverse the string on and keep track of the count of open parentheses and close parentheses with the help of two counters left and right respectively.
First, the string is traversed from the left towards the right and for every “(” encountered, the left counter is incremented by 1 and for every “)” the right counter is incremented by 1.
Whenever the left becomes equal to right, the length of the current valid string is calculated and if it greater than the current longest substring, then value of required longest substring is updated with current string length.
If the right counter becomes greater than the left counter, then the set of parentheses has become invalid and hence the left and right counters are set to 0.
After the above process, the string is similarly traversed from right to left and similar procedure is applied.

// C++ program to implement the above approach
 
#include <bits/stdc++.h>
using namespace std;
 
// Function to return the length of
// the longest valid substring
int solve(string s, int n)
{
 
    // Variables for left and right counter.
    // maxlength to store the maximum length found so far
    int left = 0, right = 0, maxlength = 0;
 
    // Iterating the string from left to right
    for (int i = 0; i < n; i++)
    {
        // If "(" is encountered,
        // then left counter is incremented
        // else right counter is incremented
        if (s[i] == '(')
            left++;
        else
            right++;
 
        // Whenever left is equal to right, it signifies
        // that the subsequence is valid and
        if (left == right)
            maxlength = max(maxlength, 2 * right);
 
        // Resetting the counters when the subsequence
        // becomes invalid
        else if (right > left)
            left = right = 0;
    }
 
    left = right = 0;
 
    // Iterating the string from right to left
    for (int i = n - 1; i >= 0; i--) {
 
        // If "(" is encountered,
        // then left counter is incremented
        // else right counter is incremented
        if (s[i] == '(')
            left++;
        else
            right++;
 
        // Whenever left is equal to right, it signifies
        // that the subsequence is valid and
        if (left == right)
            maxlength = max(maxlength, 2 * left);
 
        // Resetting the counters when the subsequence
        // becomes invalid
        else if (left > right)
            left = right = 0;
    }
    return maxlength;
}
 
 
//A much shorter and concise version of the above code
int solve2(string s, int n){
    int left=0,right=0,maxlength=0,t=2;
      while(t--){
        left=0;
        right=0;
        for(int i=0;i<n;i++){
            if(s[i]=='(')left++;
            else right++;
                 
            if(left==right){
                maxlength=max(maxlength,2*left);
            }
            //when travelling from 0 to n-1   
            if(t%2==1 && right>left){
                left=0;
                right=0;
              }
              //when travelling from n-1 to 0
              if(t%2==0 && left>right){
                  left=0;
                  right=0;
              }
            }
              //now we need to do the same thing from the other side;
            reverse(s.begin(),s.end());
        }
        return maxlength;
}
 
// Driver code
int main()
{
   
    // Function call
    cout << solve("((()()()()(((())", 16);
    return 0;
}
Output
8

Expression contains redundant bracket or not	
------------------------------------------------
Given a string of balanced expressions, find if it contains a redundant parenthesis or not. A set of parenthesis is redundant if the same sub-expression is surrounded by unnecessary or multiple brackets. Print ‘Yes‘ if redundant, else ‘No‘.

Note: Expression may contain ‘+‘, ‘*‘, ‘–‘ and ‘/‘ operators. Given expression is valid and there are no white spaces present.

Examples: 

Input: str = “((a+b))”
Output: YES
Explanation: ((a+b)) can reduced to (a+b), this Redundant

Input: str = “(a+(b)/c)”
Output: YES
Explanation: (a+(b)/c) can reduced to (a+b/c) because b is surrounded by () which is redundant.

using Stack
The idea is to use the stack, For any sub-expression of expression, if we are able to pick any sub-expression of expression surrounded by (), then we are again left with ( ) as part of the string, we have redundant braces. 

Follow the steps mentioned below to implement the approach:

We iterate through the given expression and for each character in the expression
if the character is an open parenthesis ‘(‘ or any of the operators or operands, we push it to the stack.
If the character is close parenthesis ‘)’, then pop characters from the stack till matching open parenthesis ‘(‘ is found.
Now for redundancy two conditions will arise while popping.
If immediate pop hits an open parenthesis ‘(‘, then we have found a duplicate parenthesis. For example, (((a+b))+c) has duplicate brackets around a+b. When we reach the second “)” after a+b, we have “((” in the stack. Since the top of the stack is an opening bracket, we conclude that there are duplicate brackets. 
If immediate pop doesn’t hit any operand(‘*’, ‘+’, ‘/’, ‘-‘) then it indicates the presence of unwanted brackets surrounded by expression. For instance, (a)+b contains unwanted () around a thus it is redundant.  

/* C++ Program to check whether valid expression is redundant or not*/
#include <bits/stdc++.h>
using namespace std;
 
// Function to check redundant brackets in a
// balanced expression
bool checkRedundancy(string& str)
{
    // create a stack of characters
    stack<char> st;
 
    // Iterate through the given expression
    for (auto& ch : str) {
 
        // if current character is close parenthesis ')'
        if (ch == ')') {
            char top = st.top();
            st.pop();
 
            // If immediate pop have open parenthesis '('
            // duplicate brackets found
            bool flag = true;
 
            while (!st.empty() and top != '(') {
 
                // Check for operators in expression
                if (top == '+' || top == '-' ||
                    top == '*' || top == '/')
                    flag = false;
 
                // Fetch top element of stack
                top = st.top();
                st.pop();
            }
 
            // If operators not found
            if (flag == true)
                return true;
        }
 
        else
            st.push(ch); // push open parenthesis '(',
                  // operators and operands to stack
    }
    return false;
}
 
// Function to check redundant brackets
void findRedundant(string& str)
{
    bool ans = checkRedundancy(str);
    if (ans == true)
        cout << "Yes\n";
    else
        cout << "No\n";
}
 
// Driver code
int main()
{
    string str = "((a+b))";
    findRedundant(str);
    return 0;
}
Output
Yes
Time Complexity: O(N)
Auxiliary Space: O(N)

Implement Stack using Queue	
---------------------------------------------
Given a Queue data structure that supports standard operations like enqueue() and dequeue(). The task is to implement a Stack data structure using only instances of Queue and Queue operations allowed on the instances.

A Stack can be implemented using two queues. Let Stack to be implemented be ‘s’ and queues used to implement are ‘q1’ and ‘q2’. Stack ‘s’ can be implemented in two ways:

Using Queues By making push() operation costly:

The idea is to keep newly entered element at the front of ‘q1’ so that pop operation dequeues from ‘q1’. ‘q2’ is used to put every new element in front of ‘q1’.

Follow the below steps to implement the push(s, x) operation: 
Enqueue x to q2.
One by one dequeue everything from q1 and enqueue to q2.
Swap the queues of q1 and q2.
Follow the below steps to implement the pop(s) operation: 
Dequeue an item from q1 and return it.

/* Program to implement a stack using two queue */
#include <bits/stdc++.h>
 
using namespace std;
 
class Stack {
    // Two inbuilt queues
    queue<int> q1, q2;
 
public:
    void push(int x)
    {
        // Push x first in empty q2
        q2.push(x);
 
        // Push all the remaining
        // elements in q1 to q2.
        while (!q1.empty()) {
            q2.push(q1.front());
            q1.pop();
        }
 
        // swap the names of two queues
        queue<int> q = q1;
        q1 = q2;
        q2 = q;
    }
 
    void pop()
    {
        // if no elements are there in q1
        if (q1.empty())
            return;
        q1.pop();
    }
 
    int top()
    {
        if (q1.empty())
            return -1;
        return q1.front();
    }
 
    int size() { return q1.size(); }
};
 
// Driver code
int main()
{
    Stack s;
    s.push(1);
    s.push(2);
    s.push(3);
 
    cout << "current size: " << s.size() << endl;
    cout << s.top() << endl;
    s.pop();
    cout << s.top() << endl;
    s.pop();
    cout << s.top() << endl;
 
    cout << "current size: " << s.size() << endl;
    return 0;
}
Output
current size: 3
3
2
1
current size: 1
Time Complexity:

Push operation: O(N), As all the elements need to be popped out from the Queue (q1) and push them back to Queue (q2).
Pop operation: O(1), As we need to remove the front element from the Queue.
Auxiliary Space: O(N), As we use two queues for the implementation of a Stack.

Implement Stack using Queues by making pop() operation costly:
Below is the idea to solve the problem:

The new element is always enqueued to q1. In pop() operation, if q2 is empty then all the elements except the last, are moved to q2. Finally, the last element is dequeued from q1 and returned.

Follow the below steps to implement the push(s, x) operation: 
Enqueue x to q1 (assuming the size of q1 is unlimited).
Follow the below steps to implement the pop(s) operation: 
One by one dequeue everything except the last element from q1 and enqueue to q2.
Dequeue the last item of q1, the dequeued item is the result, store it.
Swap the names of q1 and q2
Return the item stored in step 2.

// Program to implement a stack
// using two queue
#include <bits/stdc++.h>
using namespace std;
 
class Stack {
    queue<int> q1, q2;
 
public:
    void pop()
    {
        if (q1.empty())
            return;
 
        // Leave one element in q1 and
        // push others in q2.
        while (q1.size() != 1) {
            q2.push(q1.front());
            q1.pop();
        }
 
        // Pop the only left element
        // from q1
        q1.pop();
 
        // swap the names of two queues
        queue<int> q = q1;
        q1 = q2;
        q2 = q;
    }
 
    void push(int x) { q1.push(x); }
 
    int top()
    {
        if (q1.empty())
            return -1;
 
        while (q1.size() != 1) {
            q2.push(q1.front());
            q1.pop();
        }
 
        // last pushed element
        int temp = q1.front();
 
        // to empty the auxiliary queue after
        // last operation
        q1.pop();
 
        // push last element to q2
        q2.push(temp);
 
        // swap the two queues names
        queue<int> q = q1;
        q1 = q2;
        q2 = q;
        return temp;
    }
 
    int size() { return q1.size(); }
};
 
// Driver code
int main()
{
    Stack s;
    s.push(1);
    s.push(2);
    s.push(3);
 
    cout << "current size: " << s.size() << endl;
    cout << s.top() << endl;
    s.pop();
    cout << s.top() << endl;
    s.pop();
    cout << s.top() << endl;
    cout << "current size: " << s.size() << endl;
    return 0;
}
Output
current size: 3
3
2
1
current size: 1
Time Complexity: 

Push operation: O(1), As, on each push operation the new element is added at the end of the Queue.
Pop operation: O(N), As, on each pop operation, all the elements are popped out from the Queue (q1) except the last element and pushed into the Queue (q2).
Auxiliary Space: O(N) since 2 queues are used.

Implement Stack using 1 queue:
Below is the idea to solve the problem:

Using only one queue and make the queue act as a Stack in modified way of the above discussed approach.

Follow the below steps to implement the idea: 

The idea behind this approach is to make one queue and push the first element in it. 
After the first element, we push the next element and then push the first element again and finally pop the first element. 
So, according to the FIFO rule of the queue, the second element that was inserted will be at the front and then the first element as it was pushed again later and its first copy was popped out. 
So, this acts as a Stack and we do this at every step i.e. from the initial element to the second last element, and the last element will be the one which we are inserting and since we will be pushing the initial elements after pushing the last element, our last element becomes the first element.

#include <bits/stdc++.h>
using namespace std;
 
// Stack Class that acts as a queue
class Stack {
 
    queue<int> q;
 
public:
    void push(int data);
    void pop();
    int top();
    int size();
    bool empty();
};
 
// Push operation
void Stack::push(int data)
{
    //  Get previous size of queue
    int s = q.size();
 
    // Push the current element
    q.push(data);
 
    // Pop all the previous elements and put them after
    // current element
 
    for (int i = 0; i < s; i++) {
        // Add the front element again
        q.push(q.front());
 
        // Delete front element
        q.pop();
    }
}
 
// Removes the top element
void Stack::pop()
{
    if (q.empty())
        cout << "No elements\n";
    else
        q.pop();
}
 
// Returns top of stack
int Stack::top() { return (q.empty()) ? -1 : q.front(); }
 
// Returns true if Stack is empty else false
bool Stack::empty() { return (q.empty()); }
 
int Stack::size() { return q.size(); }
 
int main()
{
    Stack st;
    st.push(1);
    st.push(2);
    st.push(3);
    cout << "current size: " << st.size() << "\n";
    cout << st.top() << "\n";
    st.pop();
    cout << st.top() << "\n";
    st.pop();
    cout << st.top() << "\n";
    cout << "current size: " << st.size();
    return 0;
}
Output
current size: 3
3
2
1
current size: 1
Time Complexity:
Push operation: O(N)
Pop operation: O(1)
Auxiliary Space: O(N) since 1 queue is used.

Implement Stack using Deque	
---------------------------------
Deque also known as double ended queue, as name suggests is a special kind of queue in which insertions and deletions can be done at the last as well as at the beginning.

A link-list representation of deque is such that each node points to the next node as well as the previous node. So that insertion and deletions take constant time at both the beginning and the last.








Now, deque can be used to implement a stack and queue. One simply needs to understand how deque can made to work as a stack or a queue.


The functions of deque to tweak them to work as stack and queue are list below.














Examples: Stack 

Input : Stack : 1 2 3
        Push(4)
Output : Stack : 1 2 3 4

Input : Stack : 1 2 3
        Pop()
Output : Stack : 1 2
Examples: Queue 

Input: Queue : 1 2 3
       Enqueue(4)
Output: Queue : 1 2 3 4

Input: Queue : 1 2 3
       Dequeue()
Output: Queue : 2 3

// C++ Program to implement stack and queue using Deque
#include <bits/stdc++.h>
using namespace std;
 
// structure for a node of deque
struct DQueNode {
    int value;
    DQueNode* next;
    DQueNode* prev;
};
 
// Implementation of deque class
class Deque {
private:
 
    // pointers to head and tail of deque
    DQueNode* head;
    DQueNode* tail;
 
public:
    // constructor
    Deque()
    {
        head = tail = NULL;
    }
 
    // if list is empty
    bool isEmpty()
    {
        if (head == NULL)
            return true;
        return false;
    }
 
    // count the number of nodes in list
    int size()
    {
        // if list is not empty
        if (!isEmpty()) {
            DQueNode* temp = head;
            int len = 0;
            while (temp != NULL) {
                len++;
                temp = temp->next;
            }
            return len;
        }
        return 0;
    }
 
    // insert at the first position
    void insert_first(int element)
    {
        // allocating node of DQueNode type
        DQueNode* temp = new DQueNode[sizeof(DQueNode)];
        temp->value = element;
 
        // if the element is first element
        if (head == NULL) {
            head = tail = temp;
            temp->next = temp->prev = NULL;
        }
        else {
            head->prev = temp;
            temp->next = head;
            temp->prev = NULL;
            head = temp;
        }
    }
 
    // insert at last position of deque
    void insert_last(int element)
    {
        // allocating node of DQueNode type
        DQueNode* temp = new DQueNode[sizeof(DQueNode)];
        temp->value = element;
 
        // if element is the first element
        if (head == NULL) {
            head = tail = temp;
            temp->next = temp->prev = NULL;
        }
        else {
            tail->next = temp;
            temp->next = NULL;
            temp->prev = tail;
            tail = temp;
        }
    }
 
    // remove element at the first position
    void remove_first()
    {
        // if list is not empty
        if (!isEmpty()) {
            DQueNode* temp = head;
            head = head->next;
            if(head) head->prev = NULL;
            delete temp;
            if(head == NULL) tail = NULL;
            return;
        }
        cout << "List is Empty" << endl;
    }
 
    // remove element at the last position
    void remove_last()
    {
        // if list is not empty
        if (!isEmpty()) {
            DQueNode* temp = tail;
            tail = tail->prev;
            if(tail) tail->next = NULL;
            delete temp;
            if(tail == NULL) head = NULL;
            return;
        }
        cout << "List is Empty" << endl;
    }
 
    // displays the elements in deque
    void display()
    {
        // if list is not empty
        if (!isEmpty()) {
            DQueNode* temp = head;
            while (temp != NULL) {
                cout << temp->value << " ";
                temp = temp->next;
            }
            cout << endl;
            return;
        }
        cout << "List is Empty" << endl;
    }
};
 
// Class to implement stack using Deque
class Stack : public Deque {
public:
    // push to push element at top of stack using insert at last function of deque
    void push(int element)
    {
        insert_last(element);
    }
 
    // pop to remove element at top of stack using remove at last function of deque
    void pop()
    {
        remove_last();
    }
};
 
// class to implement queue using deque
class Queue : public Deque {
public:
    // enqueue to insert element at last using insert at last function of deque
    void enqueue(int element)
    {
        insert_last(element);
    }
 
    // dequeue to remove element from first using remove at first function of deque
    void dequeue()
    {
        remove_first();
    }
};
 
// Driver Code
int main()
{
    // object of Stack
    Stack stk;
 
    // push 7 and 8 at top of stack
    stk.push(7);
    stk.push(8);
    cout << "Stack: ";
    stk.display();
 
    // pop an element
    stk.pop();
    cout << "Stack: ";
    stk.display();
 
    // object of Queue
    Queue que;
 
    // insert 12 and 13 in queue
    que.enqueue(12);
    que.enqueue(13);
    cout << "Queue: ";
    que.display();
 
    // delete an element from queue
    que.dequeue();
    cout << "Queue: ";
    que.display();
 
    cout << "Size of Stack is " << stk.size() << endl;
    cout << "Size of Queue is " << que.size() << endl;
    return 0;
}
Output
Stack: 7 8 
Stack: 7 
Queue: 12 13 
Queue: 13 
Size of Stack is 1
Size of Queue is 1
Time Complexity: O(n)
Auxiliary Space: O(n)

Stack Permutations (Check if an array is stack permutation of other)	
---------------------------------------------------------------------------
A stack permutation is a permutation of objects in the given input queue which is done by transferring elements from the input queue to the output queue with the help of a stack and the built-in push and pop functions.

The rules are: 

Only dequeue from the input queue.
Use inbuilt push, and pop functions in the single stack.
Stack and input queue must be empty at the end.
Only enqueue to the output queue.
There are a huge number of permutations possible using a stack for a single input queue. 
Given two arrays, both of unique elements. One represents the input queue and the other represents the output queue. Our task is to check if the given output is possible through stack permutation.

Examples: 

Input: arr1[] = [ 1, 2, 3 ] , arr2[] = [ 2, 1, 3 ]
Output: YES
Explanation: 
push 1 from input to stack
push 2 from input to stack
pop 2 from stack to output
pop 1 from stack to output
push 3 from input to stack
pop 3 from stack to output

Input: arr1[] = [ 1, 2, 3 ] , arr2[] = [ 3, 1, 2 ]
Output: Not Possible

Stack Permutation Using Stack
The idea is to try to convert the input queue to the output queue using a stack, if we are able to do so then the queue is permutable otherwise not. 

Follow the steps mentioned below to implement the approach:

Continuously pop elements from the input queue and check if it is equal to the top of output queue or not, if it is not equal to the top of output queue then we will push the element to stack. 
Once we find an element in input queue such the top of input queue is equal to top of output queue, we will pop a single element from both input and output queues, and compare the top of stack and top of output queue now. If top of both stack and output queue are equal then pop element from both stack and output queue. If not equal, go to step 1.
Repeat above two steps until the input queue becomes empty. At the end if both of the input queue and stack are empty then the input queue is permutable otherwise not. 

// Given two arrays, check if one array is
// stack permutation of other.
#include<bits/stdc++.h>
using namespace std;
 
// function to check if input queue is
// permutable to output queue
bool checkStackPermutation(int ip[], int op[], int n)
{
    // Input queue
    queue<int> input;
    for (int i=0;i<n;i++)
        input.push(ip[i]);
 
    // output queue
    queue<int> output;
    for (int i=0;i<n;i++)
        output.push(op[i]);
 
    // stack to be used for permutation
    stack <int> tempStack;
    while (!input.empty())
    {
        int ele = input.front();
        input.pop();
        if (ele == output.front())
        {
            output.pop();
            while (!tempStack.empty())
            {
                if (tempStack.top() == output.front())
                {
                    tempStack.pop();
                    output.pop();
                }
                else
                    break;
            }
        }
        else
            tempStack.push(ele);
    }
 
    // If after processing, both input queue and
    // stack are empty then the input queue is
    // permutable otherwise not.
    return (input.empty()&&tempStack.empty());
}
 
// Driver program to test above function
int main()
{
    // Input Queue
    int input[] = {1, 2, 3};
 
    // Output Queue
    int output[] = {2, 1, 3};
 
    int n = 3;
 
    if (checkStackPermutation(input, output, n))
        cout << "Yes";
    else
        cout << "Not Possible";
    return 0;
}
Output
Yes
Time Complexity: O(N)
Auxiliary Space: O(N)

Optimized Approach
The idea to start iterating on the input array and storing its element one by one in a stack and if the top of our stack matches with an element in the output array we will pop that element from the stack and compare the next element of the output array with the top of our stack if again it matches then again pop until our stack isn’t empty 

// Given two arrays, check if one array is
// stack permutation of other.
#include<bits/stdc++.h>
using namespace std;
 
// function to check if input array is
// permutable to output array
bool checkStackPermutation(int ip[], int op[], int n)
{
     // we will be pushing elements from input array to stack uptill top of our stack
     //  matches with first element of output array
      stack<int>s;
      
    // will maintain a variable j to iterate on output array
      int j=0;
   
    // will iterate one by one in input array
      for(int i=0;i<n;i++)
      {
        // pushed an element from input array to stack
        s.push(ip[i]);
        // if our stack isn't empty and top matches with output array
        // then we will keep popping out from stack uptill top matches with
        // output array
        while(!s.empty() and s.top()==op[j])
        {
          s.pop();
          // increasing j so next time we can compare next element in output array
          j++;
        }
      }
       
      // if output array was a correct permutation of input array then
      // by now our stack should be empty
      if(s.empty())
      {
        return true;
      }
      return false; 
       
}
 
// Driver program to test above function
int main()
{
    // Input Array
    int input[] = {4,5,6,7,8};
 
    // Output Array
    int output[] = {8,7,6,5,4};
 
    int n = 5;
 
    if (checkStackPermutation(input, output, n))
        cout << "Yes";
    else
        cout << "Not Possible";
    return 0;
}
Output
Yes
Time Complexity: O(N)
Auxiliary Space: O(N)

Implement Queue using Stack	
-------------------------------------------
We are given a stack data structure with push and pop operations, the task is to implement a queue using instances of stack data structure and operations on them.

A queue can be implemented using two stacks. Let queue to be implemented be q and stacks used to implement q be stack1 and stack2. q can be implemented in two ways: 

Method 1 (By making enQueue operation costly): This method makes sure that oldest entered element is always at the top of stack 1, so that deQueue operation just pops from stack1. To put the element at top of stack1, stack2 is used.


enQueue(q, x): 

While stack1 is not empty, push everything from stack1 to stack2.
Push x to stack1 (assuming size of stacks is unlimited).
Push everything back to stack1.
Here time complexity will be O(n)

deQueue(q): 

If stack1 is empty then error
Pop an item from stack1 and return it
Here time complexity will be O(1)

// CPP program to implement Queue using two stacks with costly enQueue()
#include <bits/stdc++.h>
using namespace std;
 
struct Queue {
    stack<int> s1, s2;
 
    void enQueue(int x)
    {
        // Move all elements from s1 to s2
        while (!s1.empty()) {
            s2.push(s1.top());
            s1.pop();
        }
 
        // Push item into s1
        s1.push(x);
 
        // Push everything back to s1
        while (!s2.empty()) {
            s1.push(s2.top());
            s2.pop();
        }
    }
 
    // Dequeue an item from the queue
    int deQueue()
    {
        // if first stack is empty
        if (s1.empty()) {
            cout << "Q is Empty";
            exit(0);
        }
 
        // Return top of s1
        int x = s1.top();
        s1.pop();
        return x;
    }
};
 
// Driver code
int main()
{
    Queue q;
    q.enQueue(1);
    q.enQueue(2);
    q.enQueue(3);
 
    cout << q.deQueue() << '\n';
    cout << q.deQueue() << '\n';
    cout << q.deQueue() << '\n';
 
    return 0;
}
Output: 

1
2
3

Complexity Analysis: 
Time Complexity: 
Push operation: O(N). 
In the worst case we have empty whole of stack 1 into stack 2.
Pop operation: O(1). 
Same as pop operation in stack.
Auxiliary Space: O(N). 
Use of stack for storing values.

Method 2 (By making deQueue operation costly): In this method, in en-queue operation, the new element is entered at the top of stack1. In de-queue operation, if stack2 is empty then all the elements are moved to stack2 and finally top of stack2 is returned. 

enQueue(q,  x)
  1) Push x to stack1 (assuming size of stacks is unlimited).
Here time complexity will be O(1)

deQueue(q)
  1) If both stacks are empty then error.
  2) If stack2 is empty
       While stack1 is not empty, push everything from stack1 to stack2.
  3) Pop the element from stack2 and return it.
Here time complexity will be O(n)
Method 2 is definitely better than method 1. 


Method 1 moves all the elements twice in enQueue operation, while method 2 (in deQueue operation) moves the elements once and moves elements only if stack2 empty. So, the amortized complexity of the dequeue operation becomes \Theta (1)

Implementation of method 2:

// CPP program to implement Queue using two stacks with costly deQueue()
#include <bits/stdc++.h>
using namespace std;
 
struct Queue {
    stack<int> s1, s2;
 
    // Enqueue an item to the queue
    void enQueue(int x)
    {
        // Push item into the first stack
        s1.push(x);
    }
 
    // Dequeue an item from the queue
    int deQueue()
    {
        // if both stacks are empty
        if (s1.empty() && s2.empty()) {
            cout << "Q is empty";
            exit(0);
        }
 
        // if s2 is empty, move elements from s1
        if (s2.empty()) {
            while (!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
 
        // return the top item from s2
        int x = s2.top();
        s2.pop();
        return x;
    }
};
 
// Driver code
int main()
{
    Queue q;
    q.enQueue(1);
    q.enQueue(2);
    q.enQueue(3);
 
    cout << q.deQueue() << '\n';
    cout << q.deQueue() << '\n';
    cout << q.deQueue() << '\n';
 
    return 0;
}
Output: 
1 2 3 

Complexity Analysis: 

Time Complexity: 
Push operation: O(1). 
Same as pop operation in stack.
Pop operation: O(N) in general and O(1) amortized time complexity.
In the worst case we have to empty the whole of stack 1 into stack 2 so its O(N). Amortized time is the way to express the time complexity when an algorithm has the very bad time complexity only once in a while besides the time complexity that happens most of time. So its O(1) amortized time complexity, since we have to empty whole of stack 1 only when stack 2 is empty, rest of the times the pop operation takes O(1) time.
Auxiliary Space: O(N). 
Use of stack for storing values.
Queue can also be implemented using one user stack and one Function Call Stack. Below is modified Method 2 where recursion (or Function Call Stack) is used to implement queue using only one user defined stack. 

enQueue(x)
  1) Push x to stack1.

deQueue:
  1) If stack1 is empty then error.
  2) If stack1 has only one element then return it.
  3) Recursively pop everything from the stack1, store the popped item 
    in a variable res,  push the res back to stack1 and return res
The step 3 makes sure that the last popped item is always returned and since the recursion stops when there is only one item in stack1 (step 2), we get the last element of stack1 in deQueue() and all other items are pushed back in step 

 
Using Function Call Stack:  

// CPP program to implement Queue using one stack and recursive call stack.
#include <bits/stdc++.h>
using namespace std;
 
struct Queue {
    stack<int> s;
 
    // Enqueue an item to the queue
    void enQueue(int x)
    {
        s.push(x);
    }
 
    // Dequeue an item from the queue
    int deQueue()
    {
        if (s.empty()) {
            cout << "Q is empty";
            exit(0);
        }
 
        // pop an item from the stack
        int x = s.top();
        s.pop();
 
        // if stack becomes empty, return
        // the popped item
        if (s.empty())
            return x;
 
        // recursive call
        int item = deQueue();
 
        // push popped item back to the stack
        s.push(x);
 
        // return the result of deQueue() call
        return item;
    }
};
 
// Driver code
int main()
{
    Queue q;
    q.enQueue(1);
    q.enQueue(2);
    q.enQueue(3);
 
    cout << q.deQueue() << '\n';
    cout << q.deQueue() << '\n';
    cout << q.deQueue() << '\n';
 
    return 0;
}
Output: 
1 2 3 

Complexity Analysis: 
Time Complexity: 
Push operation : O(1). 
Same as pop operation in stack.
Pop operation : O(N). 
The difference from above method is that in this method element is returned and all elements are restored back in a single call.
Auxiliary Space: O(N). 
Use of stack for storing values.
 
Implement “n” queue in an array	
------------------------------------------
Create a data structure kQueues that represents k queues. Implementation of kQueues should use only one array, i.e., k queues should use the same array for storing elements. Following functions must be supported by kQueues.

enqueue(int x, int qn) –> adds x to queue number ‘qn’ where qn is from 0 to k-1 
dequeue(int qn) –> deletes an element from queue number ‘qn’ where qn is from 0 to k-1 

Method 1 (Divide the array in slots of size n/k):

A simple way to implement k queues is to divide the array in k slots of size n/k each, and fix the slots for different queues, i.e., use arr[0] to arr[n/k-1] for the first queue, and arr[n/k] to arr[2n/k-1] for queue2 where arr[] is the array to be used to implement two queues and size of array be n.

The problem with this method is an inefficient use of array space. An enqueue operation may result in overflow even if there is space available in arr[]. For example, consider k as 2 and array size n as 6. Let we enqueue 3 elements to first and do not enqueue anything to the second queue. When we enqueue the 4th element to the first queue, there will be overflow even if we have space for 3 more elements in the array.


Method 2 (A space efficient implementation):

The idea is similar to the stack post, here we need to use three extra arrays. In stack post, we needed two extra arrays, one more array is required because in queues, enqueue() and dequeue() operations are done at different ends.

Following are the three extra arrays are used: 

front[]: This is of size k and stores indexes of front elements in all queues. 
rear[]: This is of size k and stores indexes of rear elements in all queues. 
next[]: This is of size n and stores indexes of next item for all items in array arr[]. 
Here arr[] is the actual array that stores k stacks.

Together with k queues, a stack of free slots in arr[] is also maintained. The top of this stack is stored in a variable ‘free’.

All entries in front[] are initialized as -1 to indicate that all queues are empty. All entries next[i] are initialized as i+1 because all slots are free initially and pointing to the next slot. Top of the free stack, ‘free’ is initialized as 0.

// A C++ program to demonstrate implementation of k queues in a single array in time and space efficient way
#include<iostream>
#include<climits>
using namespace std;
 
// A C++ class to represent k queues in a single array of size n
class kQueues
{  
    // Array of size n to store actual content to be stored in queue
    int *arr;
 
    // Array of size k to store indexes of front elements of the queue 
    int *front;  
 
    // Array of size k to store indexes of rear elements of queue
    int *rear;
 
    // Array of size n to store next entry in all queues           
    int *next; 
    int n, k;
 
    int free; // To store the beginning index of the free list
 
public:
    //constructor to create k queue in an array of size n
    kQueues(int k, int n);
 
    // A utility function to check if there is space available
    bool isFull()   {  return (free == -1);  }
 
    // To enqueue an item in queue number 'qn' where qn is from 0 to k-1
    void enqueue(int item, int qn);
 
    // To dequeue an from queue number 'qn' where qn is from 0 to k-1
    int dequeue(int qn);
 
    // To check whether queue number 'qn' is empty or not
    bool isEmpty(int qn)  {  return (front[qn] == -1); }
};
 
// Constructor to create k queues in an array of size n
kQueues::kQueues(int k1, int n1)
{
    // Initialize n and k, and allocate memory for all arrays
    k = k1, n = n1;
    arr = new int[n];
    front = new int[k];
    rear = new int[k];
    next = new int[n];
 
    // Initialize all queues as empty
    for (int i = 0; i < k; i++)
        front[i] = -1;
 
    // Initialize all spaces as free
    free = 0;
    for (int i=0; i<n-1; i++)
        next[i] = i+1;
    next[n-1] = -1;  // -1 is used to indicate end of free list
}
 
// To enqueue an item in queue number'qn' where qn is from 0 to k-1
void kQueues::enqueue(int item, int qn)
{
    // Overflow check
    if (isFull())
    {
        cout << "\nQueue Overflow\n";
        return;
    }
 
    int i = free;      // Store index of first free slot
 
    // Update index of free slot to index of next slot in free list
    free = next[i];
 
    if (isEmpty(qn))
        front[qn] = i;
    else
        next[rear[qn]] = i;
 
    next[i] = -1;
 
    // Update next of rear and then rear for queue number 'qn'
    rear[qn] = i;
 
    // Put the item in array
    arr[i] = item;
}
 
// To dequeue an from queue number 'qn' where qn is from 0 to k-1
int kQueues::dequeue(int qn)
{
    // Underflow checkSAS
    if (isEmpty(qn))
    {
         cout << "\nQueue Underflow\n";
         return INT_MAX;
    }
 
    // Find index of front item in queue number 'qn'
    int i = front[qn];
   
    // Change top to store next of previous top
    front[qn] = next[i];
 
    // Attach the previous front to the beginning of free list
    next[i] = free;
    free = i;
 
    // Return the previous front item
    return arr[i];
}
 
/* Driver program to test kStacks class */
int main()
{
    // Let us create 3 queue in an array of size 10
    int k = 3, n = 10;
    kQueues ks(k, n);
 
    // Let us put some items in queue number 2
    ks.enqueue(15, 2);
    ks.enqueue(45, 2);
 
    // Let us put some items in queue number 1
    ks.enqueue(17, 1);
    ks.enqueue(49, 1);
    ks.enqueue(39, 1);
 
    // Let us put some items in queue number 0
    ks.enqueue(11, 0);
    ks.enqueue(9, 0);
    ks.enqueue(7, 0);
 
    cout << "Dequeued element from queue 2 is " << ks.dequeue(2) << endl;
    cout << "Dequeued element from queue 1 is " << ks.dequeue(1) << endl;
    cout << "Dequeued element from queue 0 is " << ks.dequeue(0) << endl;
 
    return 0;
}
Output
Dequeued element from queue 2 is 15
Dequeued element from queue 1 is 17
Dequeued element from queue 0 is 11
Time complexities of enqueue() and dequeue() is O(1).

The best part of the above implementation is, if there is a slot available in the queue, then an item can be enqueued in any of the queues, i.e., no wastage of space. This method requires some extra space. Space may not be an issue because queue items are typically large, for example, queues of employees, students, etc where every item is of hundreds of bytes. For such large queues, the extra space used is comparatively very less as we use three integer arrays as extra space.

Implement a Circular queue	
-----------------------------------
What is a Circular Queue?
A Circular Queue is a special version of queue where the last element of the queue is connected to the first element of the queue forming a circle.

The operations are performed based on FIFO (First In First Out) principle. It is also called ‘Ring Buffer’. 
 




In a normal Queue, we can insert elements until queue becomes full. But once queue becomes full, we can not insert the next element even if there is a space in front of queue.
 







Operations on Circular Queue:
Front: Get the front item from queue.
Rear: Get the last item from queue.
enQueue(value) This function is used to insert an element into the circular queue. In a circular queue, the new element is always inserted at Rear position. 
Check whether queue is Full – Check ((rear == SIZE-1 && front == 0) || (rear == front-1)).
If it is full then display Queue is full. If queue is not full then, check if (rear == SIZE – 1 && front != 0) if it is true then set rear=0 and insert element.
deQueue() This function is used to delete an element from the circular queue. In a circular queue, the element is always deleted from front position. 
Check whether queue is Empty means check (front==-1).
If it is empty then display Queue is empty. If queue is not empty then step 3
Check if (front==rear) if it is true then set front=rear= -1 else check if (front==size-1), if it is true then set front=0 and return the element.

Implementation:

// C or C++ program for insertion and deletion in Circular Queue
#include<bits/stdc++.h>
using namespace std;
  
class Queue
{
    // Initialize front and rear
    int rear, front;
  
    // Circular Queue
    int size;
    int *arr;
public:
    Queue(int s)
    {
       front = rear = -1;
       size = s;
       arr = new int[s];
    }
  
    void enQueue(int value);
    int deQueue();
    void displayQueue();
};
  
  
/* Function to create Circular queue */
void Queue::enQueue(int value)
{
    if ((front == 0 && rear == size-1) ||
            (rear == (front-1)%(size-1)))
    {
        printf("\nQueue is Full");
        return;
    }
  
    else if (front == -1) /* Insert First Element */
    {
        front = rear = 0;
        arr[rear] = value;
    }
  
    else if (rear == size-1 && front != 0)
    {
        rear = 0;
        arr[rear] = value;
    }
  
    else
    {
        rear++;
        arr[rear] = value;
    }
}
  
// Function to delete element from Circular Queue
int Queue::deQueue()
{
    if (front == -1)
    {
        printf("\nQueue is Empty");
        return INT_MIN;
    }
  
    int data = arr[front];
    arr[front] = -1;
    if (front == rear)
    {
        front = -1;
        rear = -1;
    }
    else if (front == size-1)
        front = 0;
    else
        front++;
  
    return data;
}
  
// Function displaying the elements of Circular Queue
void Queue::displayQueue()
{
    if (front == -1)
    {
        printf("\nQueue is Empty");
        return;
    }
    printf("\nElements in Circular Queue are: ");
    if (rear >= front)
    {
        for (int i = front; i <= rear; i++)
            printf("%d ",arr[i]);
    }
    else
    {
        for (int i = front; i < size; i++)
            printf("%d ", arr[i]);
  
        for (int i = 0; i <= rear; i++)
            printf("%d ", arr[i]);
    }
}
  
/* Driver of the program */
int main()
{
    Queue q(5);
  
    // Inserting elements in Circular Queue
    q.enQueue(14);
    q.enQueue(22);
    q.enQueue(13);
    q.enQueue(-6);
  
    // Display elements present in Circular Queue
    q.displayQueue();
  
    // Deleting elements from Circular Queue
    printf("\nDeleted value = %d", q.deQueue());
    printf("\nDeleted value = %d", q.deQueue());
  
    q.displayQueue();
  
    q.enQueue(9);
    q.enQueue(20);
    q.enQueue(5);
  
    q.displayQueue();
  
    q.enQueue(20);
    return 0;
}
Output
Elements in Circular Queue are: 14 22 13 -6 
Deleted value = 14
Deleted value = 22
Elements in Circular Queue are: 13 -6 
Elements in Circular Queue are: 13 -6 9 20 5 
Queue is Full
Time Complexity: Time complexity of enQueue(), deQueue() operation is O(1) as there is no loop in any of the operation.

Applications:
Memory Management: The unused memory locations in the case of ordinary queues can be utilized in circular queues.
Traffic system: In computer controlled traffic system, circular queues are used to switch on the traffic lights one by one repeatedly as per the time set.
CPU Scheduling: Operating systems often maintain a queue of processes that are ready to execute or that are waiting for a particular event to occur.

LRU Cache Implementation	
-----------------------------
How to implement LRU caching scheme? What data structures should be used? 
We are given the total possible page numbers that can be referred. We are also given a cache (or memory) size (The number of page frames that the cache can hold at a time). The LRU caching scheme is to remove the least recently used frame when the cache is full and a new page is referenced which is not there in the cache. Please see the Galvin book for more details

We use two data structures to implement an LRU Cache.  

Queue is implemented using a doubly-linked list. The maximum size of the queue will be equal to the total number of frames available (cache size). The most recently used pages will be near the front end and the least recently used pages will be near the rear end.
A Hash with the page number as key and the address of the corresponding queue node as value.
When a page is referenced, the required page may be in the memory. If it is in the memory, we need to detach the node of the list and bring it to the front of the queue. 
If the required page is not in memory, we bring that in memory. In simple words, we add a new node to the front of the queue and update the corresponding node address in the hash. If the queue is full, i.e. all the frames are full, we remove a node from the rear of the queue, and add the new node to the front of the queue.

Example – Consider the following reference string :  

1, 2, 3, 4, 1, 2, 5, 1, 2, 3, 4, 5
Find the number of page faults using the least recently used (LRU) page replacement algorithm with 3-page frames. 

Explanation –
 












 




// We can use stl container list as a double
// ended queue to store the cache keys, with
// the descending time of reference from front
// to back and a set container to check presence
// of a key. But to fetch the address of the key
// in the list using find(), it takes O(N) time.
// This can be optimized by storing a reference
//     (iterator) to each key in a hash map.
#include <bits/stdc++.h>
using namespace std;
  
class LRUCache {
    // store keys of cache
    list<int> dq;
  
    // store references of key in cache
    unordered_map<int, list<int>::iterator> ma;
    int csize; // maximum capacity of cache
  
public:
    LRUCache(int);
    void refer(int);
    void display();
};
  
// Declare the size
LRUCache::LRUCache(int n)
{
    csize = n;
}
  
// Refers key x with in the LRU cache
void LRUCache::refer(int x)
{
    // not present in cache
    if (ma.find(x) == ma.end()) {
        // cache is full
        if (dq.size() == csize) {
            // delete least recently used element
            int last = dq.back();
  
            // Pops the last element
            dq.pop_back();
  
            // Erase the last
            ma.erase(last);
        }
    }
  
    // present in cache
    else
        dq.erase(ma[x]);
  
    // update reference
    dq.push_front(x);
    ma[x] = dq.begin();
}
  
// Function to display contents of cache
void LRUCache::display()
{
  
    // Iterate in the deque and print
    // all the elements in it
    for (auto it = dq.begin(); it != dq.end();
         it++)
        cout << (*it) << " ";
  
    cout << endl;
}
  
// Driver Code
int main()
{
    LRUCache ca(4);
  
    ca.refer(1);
    ca.refer(2);
    ca.refer(3);
    ca.refer(1);
    ca.refer(4);
    ca.refer(5);
    ca.display();
  
    return 0;
}
Output
5 4 1 3 

Reverse a Queue using recursion	
----------------------------------------
Give an algorithm for reversing a queue Q. Only the following standard operations are allowed on queue. 

enqueue(x): Add an item x to the rear of the queue.
dequeue(): Remove an item from the front of the queue.
empty(): Checks if a queue is empty or not.
The task is to reverse the queue.

Examples: 

Input: Q = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100]
Output: Q = [100, 90, 80, 70, 60, 50, 40, 30, 20, 10]

Input: [1, 2, 3, 4, 5]
Output: [5, 4, 3, 2, 1]

Using stack:
For reversing the queue one approach could be to store the elements of the queue in a temporary data structure in a manner such that if we re-insert the elements in the queue they would get inserted in reverse order. So now our task is to choose such a data structure that can serve the purpose. According to the approach, the data structure should have the property of ‘LIFO’ as the last element to be inserted in the data structure should actually be the first element of the reversed queue. 

Follow the below steps to implement the idea:

Pop the elements from the queue and insert into the stack now topmost element of the stack is the last element of the queue.
Pop the elements of the stack to insert back into the queue the last element is the first one to be inserted into the queue.

// CPP program to reverse a Queue
#include <bits/stdc++.h>
using namespace std;
 
// Utility function to print the queue
void Print(queue<int>& Queue)
{
    while (!Queue.empty()) {
        cout << Queue.front() << " ";
        Queue.pop();
    }
}
 
// Function to reverse the queue
void reverseQueue(queue<int>& Queue)
{
    stack<int> Stack;
    while (!Queue.empty()) {
        Stack.push(Queue.front());
        Queue.pop();
    }
    while (!Stack.empty()) {
        Queue.push(Stack.top());
        Stack.pop();
    }
}
 
// Driver code
int main()
{
    queue<int> Queue;
    Queue.push(10);
    Queue.push(20);
    Queue.push(30);
    Queue.push(40);
    Queue.push(50);
    Queue.push(60);
    Queue.push(70);
    Queue.push(80);
    Queue.push(90);
    Queue.push(100);
 
    reverseQueue(Queue);
    Print(Queue);
}
Output
100 90 80 70 60 50 40 30 20 10 
Time Complexity: O(N), As we need to insert all the elements in the stack and later to the queue.
Auxiliary Space: O(N), Use of stack to store values. 

Using recursion: 
Instead of explicitly using stack goal can be achieved using recursion (recursion at backend will itself maintain stack).

Recursively perform the following steps:
If the queue size is 0 return.
Else pop and store the front element and recur for remaining queue.
push the current element in the queue.

// CPP program to reverse a Queue
#include <bits/stdc++.h>
using namespace std;
 
// Utility function to print the queue
void Print(queue<int>& Queue)
{
    while (!Queue.empty()) {
        cout << Queue.front() << " ";
        Queue.pop();
    }
}
 
// Function to reverse the queue
void reverseQueue(queue<int>& q)
{
    // base case
    if (q.size() == 0)
        return;
    // storing front(first element) of queue
    int fr = q.front();
 
    // removing front
    q.pop();
 
    // asking recursion to reverse the leftover queue
    reverseQueue(q);
 
    // placing first element at its correct position
    q.push(fr);
}
 
// Driver code
int main()
{
    queue<int> Queue;
    Queue.push(10);
    Queue.push(20);
    Queue.push(30);
    Queue.push(40);
    Queue.push(50);
    Queue.push(60);
    Queue.push(70);
    Queue.push(80);
    Queue.push(90);
    Queue.push(100);
 
    reverseQueue(Queue);
    Print(Queue);
}
Output
100 90 80 70 60 50 40 30 20 10 
Time Complexity: O(N). 
Auxiliary Space: O(N). The recursion stack contains all elements of queue at a moment. 

Reverse the first “K” elements of a queue	
----------------------------------------------
Given an integer k and a queue of integers, The task is to reverse the order of the first k elements of the queue, leaving the other elements in the same relative order.

Only following standard operations are allowed on queue. 

enqueue(x) : Add an item x to rear of queue
dequeue() : Remove an item from front of queue
size() : Returns number of elements in queue.
front() : Finds front item.
Examples: 

Input : Q = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], k = 5
Output : Q = [50, 40, 30, 20, 10, 60, 70, 80, 90, 100]

Input : Q = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100], k = 4
Output : Q = [40, 30, 20, 10, 50, 60, 70, 80, 90, 100]

Approach: 

The idea is to use an auxiliary stack. Store the first k elements of the queue in a stack and pop it from the queue, then push it back to the queue and perform pop operation for n-k times and again push the popped element.

Create an empty stack.
One by one dequeue first K items from given queue and push the dequeued items to stack.
Enqueue the contents of stack at the back of the queue
Dequeue (size-k) elements from the front and enqueue them one by one to the same queue.

// C++ program to reverse first k elements of a queue.
#include <bits/stdc++.h>
using namespace std;
 
/* Function to reverse the first K elements of the Queue */
void reverseQueueFirstKElements(int k, queue<int>& Queue)
{
    if (Queue.empty() == true || k > Queue.size())
        return;
    if (k <= 0)
        return;
 
    stack<int> Stack;
 
    /* Push the first K elements into a Stack*/
    for (int i = 0; i < k; i++) {
        Stack.push(Queue.front());
        Queue.pop();
    }
 
    /* Enqueue the contents of stack at the back of the queue*/
    while (!Stack.empty()) {
        Queue.push(Stack.top());
        Stack.pop();
    }
 
    /* Remove the remaining elements and enqueue them at the end of the Queue*/
    for (int i = 0; i < Queue.size() - k; i++) {
        Queue.push(Queue.front());
        Queue.pop();
    }
}
 
/* Utility Function to print the Queue */
void Print(queue<int>& Queue)
{
    while (!Queue.empty()) {
        cout << Queue.front() << " ";
        Queue.pop();
    }
}
 
// Driver code
int main()
{
    queue<int> Queue;
    Queue.push(10);
    Queue.push(20);
    Queue.push(30);
    Queue.push(40);
    Queue.push(50);
    Queue.push(60);
    Queue.push(70);
    Queue.push(80);
    Queue.push(90);
    Queue.push(100);
 
    int k = 5;
    reverseQueueFirstKElements(k, Queue);
    Print(Queue);
}
Output
50 40 30 20 10 60 70 80 90 100 
Time Complexity: O(N + k), Where ‘n’ is the total number of elements in the queue and ‘k’ is the number of elements to be reversed. This is because firstly the whole queue is emptied into the stack and after that first ‘k’ elements are emptied and enqueued in the same way.
Auxiliary Space: O(k) where k is no of elements to be reversed since stack is being used to store values for the purpose of reversing.

Interleave the first half of the queue with second half	
----------------------------------------------------------
Given a queue of integers of even length, rearrange the elements by interleaving the first half of the queue with the second half of the queue.  

Examples:

Input :  1 2 3 4
Output : 1 3 2 4

Input : 11 12 13 14 15 16 17 18 19 20
Output : 11 16 12 17 13 18 14 19 15 20

Using Stack
Following are the steps to solve the problem: 

Push the first half elements of the queue to stack. 
Enqueue back the stack elements. 
Dequeue the first half elements of the queue and enqueue them back. 
Again push the first half elements into the stack. 
Interleave the elements of queue and stack. 

Implementation:



// C++ program to interleave the first half of the queue
// with the second half
#include <bits/stdc++.h>
using namespace std;
 
// Function to interleave the queue
void interLeaveQueue(queue<int>& q)
{
    // To check the even number of elements
    if (q.size() % 2 != 0)
        cout << "Input even number of integers." << endl;
 
    // Initialize an empty stack of int type
    stack<int> s;
    int halfSize = q.size() / 2;
 
    // Push first half elements into the stack
    // queue:16 17 18 19 20, stack: 15(T) 14 13 12 11
    for (int i = 0; i < halfSize; i++) {
        s.push(q.front());
        q.pop();
    }
 
    // enqueue back the stack elements
    // queue: 16 17 18 19 20 15 14 13 12 11
    while (!s.empty()) {
        q.push(s.top());
        s.pop();
    }
 
    // dequeue the first half elements of queue
    // and enqueue them back
    // queue: 15 14 13 12 11 16 17 18 19 20
    for (int i = 0; i < halfSize; i++) {
        q.push(q.front());
        q.pop();
    }
 
    // Again push the first half elements into the stack
    // queue: 16 17 18 19 20, stack: 11(T) 12 13 14 15
    for (int i = 0; i < halfSize; i++) {
        s.push(q.front());
        q.pop();
    }
 
    // interleave the elements of queue and stack
    // queue: 11 16 12 17 13 18 14 19 15 20
    while (!s.empty()) {
        q.push(s.top());
        s.pop();
        q.push(q.front());
        q.pop();
    }
}
 
// Driver program to test above function
int main()
{
    queue<int> q;
    q.push(11);
    q.push(12);
    q.push(13);
    q.push(14);
    q.push(15);
    q.push(16);
    q.push(17);
    q.push(18);
    q.push(19);
    q.push(20);
    interLeaveQueue(q);
    int length = q.size();
    for (int i = 0; i < length; i++) {
        cout << q.front() << " ";
        q.pop();
    }
    return 0;
}
Output
11 16 12 17 13 18 14 19 15 20 
Time complexity: O(n). Auxiliary Space: O(n).

Using Queue
We can also solve the given problem by using a queue instead of a stack. The idea is to move the first half to another queue, and then push values from the temporary queue and original queue into the original queue. The original queue will get converted to the interleaved queue after the operations.

Steps to solve : 
Make a temporary queue and push the first half of the original queue into the temp queue.
Till the temp queue is empty
  Pop the front of the temp queue and push it to the original queue
  Pop the front of the original queue and push it to the original queue
The original queue is converted to the interleaved queue.

// C++ program to interleave the first half of the queue
// with the second half using queue
#include <bits/stdc++.h>
using namespace std;
 
// Function to interleave the queue
void interLeaveQueue(queue<int>& q)
{
    // To check the even number of elements
    if (q.size() % 2 != 0)
        cout << "Input even number of integers." << endl;
 
    // Initialize an empty queue of int type
    queue<int> temp;
    int halfSize = q.size() / 2;
 
    // Push first half elements into the stack
    // queue:16 17 18 19 20, queue: 11 12 13 14 15
    for (int i = 0; i < halfSize; i++) {
        temp.push(q.front());
        q.pop();
    }
 
    // enqueue back the queue elements alternatively
    // queue: 11 16 12 17 13 18 14 19 15 20
    while (!temp.empty()) {
        q.push(temp.front());
        q.push(q.front());
        q.pop();
        temp.pop();
    }
}
 
// Driver program to test above function
int main()
{
    queue<int> q;
    q.push(11);
    q.push(12);
    q.push(13);
    q.push(14);
    q.push(15);
    q.push(16);
    q.push(17);
    q.push(18);
    q.push(19);
    q.push(20);
    interLeaveQueue(q);
    int length = q.size();
    for (int i = 0; i < length; i++) {
        cout << q.front() << " ";
        q.pop();
    }
    return 0;
}
Output
11 16 12 17 13 18 14 19 15 20 

Time complexity: O(n)  
Auxiliary Space: O(n).

Find the first circular tour that visits all Petrol Pumps	
------------------------------------------------------------
Given information about N petrol pumps (say arr[]) that are present in a circular path. The information consists of the distance of the next petrol pump from the current one (in arr[i][1]) and the amount of petrol stored in that petrol pump (in arr[i][0]). Consider a truck with infinite capacity that consumes 1 unit of petrol to travel 1 unit distance. The task is to find the index of the first starting point such that the truck can visit all the petrol pumps and come back to that starting point.

Note: Return -1 if no such tour exists.

Examples:

Input: arr[] = {{4, 6}, {6, 5}, {7, 3}, {4, 5}}. 
Output: 1
Explanation: If started from 1st index then a circular tour can be covered.

Input: arr[] {{6, 4}, {3, 6}, {7, 3}}
Output: 2

Naive Approach:

As the capacity of the truck is infinite it is feasible to fill the truck with all the amount of petrol available at each petrol pump.

A Simple Solution is to consider every petrol pumps as a starting point and see if there is a possible tour. If we find a starting point with a feasible solution, we return that starting point. 

Time Complexity: O(N2)
Auxiliary Space: O(1)

First Circular Tour Using Queue:
Instead of checking the whole array for each starting point, we can store the current tour inside a queue. 

At the moment, the current amount of petrol becomes inefficient (i.e., negative) to reach the next petrol pump, remove the current starting point from the queue and consider the next point as the new starting point.

Instead of building a separate queue, we can use the array itself as a queue with the help of start and end pointers.

Note: Each petrol pump will be added in the queue at most twice and will be removed at most once.


Illustration:

Below image is a dry run of the above approach:

















Follow the below steps to implement the idea:

Set two pointers, start = 0 and end = 1 to use the array as a queue.
If the amount of petrol is efficient to reach the next petrol pump then increment the end pointer (circularly).
Otherwise, remove the starting point of the current tour, i.e., increment the start pointer.
If the start pointer reaches N then such a tour is not possible. Otherwise, return the starting point of the tour.

// C++ program to find circular tour for a truck
#include <bits/stdc++.h>
using namespace std;
 
// A petrol pump has petrol and distance to next petrol pump
class petrolPump
{
    public:
    int petrol;
    int distance;
};
 
// The function returns starting point if there is a possible solution,
// otherwise returns -1
int printTour(petrolPump arr[], int n)
{
    // Consider first petrol pump as a starting point
    int start = 0;
    int end = 1;
 
    int curr_petrol = arr[start].petrol - arr[start].distance;
 
    /* Run a loop while all petrol pumps are not visited.
    And we have reached first petrol pump again with 0 or more petrol */
    while (end != start || curr_petrol < 0)
    {
        // If current amount of petrol in truck becomes less than 0, then
        // remove the starting petrol pump from tour
        while (curr_petrol < 0 && start != end)
        {
            // Remove starting petrol pump. Change start
            curr_petrol -= arr[start].petrol - arr[start].distance;
            start = (start + 1) % n;
 
            // If 0 is being considered as start again, then there is no
            // possible solution
            if (start == 0)
            return -1;
        }
 
        // Add a petrol pump to current tour
        curr_petrol += arr[end].petrol - arr[end].distance;
 
        end = (end + 1) % n;
    }
 
    // Return starting point
    return start;
}
 
// Driver code
int main()
{
    petrolPump arr[] = {{6, 4}, {3, 6}, {7, 3}};
 
    int n = sizeof(arr)/sizeof(arr[0]);
    int start = printTour(arr, n);
 
    (start == -1)? cout<<"No solution": cout<<"Start = "<<start;
 
    return 0;
}
 
 
Output
Start = 2
Time Complexity: O(N)
Auxiliary Space: O(1)

First Circular Tour by checking only possible valid Starting Positions:
Another efficient solution can be to find out the first petrol pump where the amount of petrol is greater than or equal to the distance to be covered to reach the next petrol pump. 

Mark that petrol pump as start and check whether we can finish the journey towards the end point. 

If in the middle, at any petrol pump, the amount of petrol is less than the distance to be covered to reach the next petrol pump, then we can say we cannot complete the circular tour from start. 
Find the next start petrol pump where the amount of petrol is greater than or equal to the distance to be covered and we mark it as start. Continue this process till all points are visited or a starting point is found.
Let us discuss why we need not look at any petrol pump in between the initial petrol pump marked as start and the new start.

Let us consider there was a petrol pump at kth position between the old start and new start. This petrol pump will break the range into two parts. The case is that 

both the parts can have negative sum, 
the starting partition can have a negative sum or 
the later half has a negative sum. 
In the first and the last case we will not be able to reach the new start point. 

And for the second case though we will be able to reach the new start but will not be able to complete the tour because we will not be able to cover some part in between 0 to the kth position. [As we already found that we could not reach to start from 0 and also we are not able to reach k from start. So the tour cannot be completed] 

Follow the steps mentioned below to implement the idea:

Find the first possible petrol pump where the amount of petrol is greater than the distance to the next petrol pump.
Traverse from i = start to N:
If the amount of petrol becomes inefficient (i.e., negative) we need to update the new start point.
Traverse from i+1 to N and find the point where petrol is greater than the distance to the next petrol pump.
Start from the new start point and continue the above procedure.
Start from 0 to the found start point. If the sum of the petrol is non-negative then the start point is feasible otherwise not.
Below is the implementation of the above approach:  


// C++ program to find circular tour for a truck
#include <bits/stdc++.h>
using namespace std;
 
// A petrol pump has petrol and distance to next petrol pump
class petrolPump {
public:
    int petrol;
    int distance;
};
 
// The function returns starting point if there is a
// possible solution, otherwise returns -1
int printTour(petrolPump arr[], int n)
{
    int start;
 
    for (int i = 0; i < n; i++) {
        // Identify the first petrol pump from where we
        // might get a full circular tour
        if (arr[i].petrol >= arr[i].distance) {
            start = i;
            break;
        }
    }
 
    // To store the excess petrol
    int curr_petrol = 0;
 
    int i;
 
    for (i = start; i < n;) {
 
        curr_petrol += (arr[i].petrol - arr[i].distance);
 
        // If at any point remaining petrol is less than 0,
        // it means that we cannot start our journey from
        // current start
        if (curr_petrol < 0) {
 
            // We move to the next petrol pump
            i++;
 
            // We try to identify the next petrol pump from
            // where we might get a full circular tour
            for (; i < n; i++) {
                if (arr[i].petrol >= arr[i].distance) {
 
                    start = i;
 
                    // Reset rem_petrol
                    curr_petrol = 0;
 
                    break;
                }
            }
        }
 
        else {
            // Move to the next petrolpump if curr_petrol is
            // >= 0
            i++;
        }
    }
 
    // If remaining petrol is less than 0 while we reach the
    // first petrol pump, it means no circular tour is
    // possible
    if (curr_petrol < 0) {
        return -1;
    }
 
    for (int j = 0; j < start; j++) {
 
        curr_petrol += (arr[j].petrol - arr[j].distance);
 
        // If remaining petrol is less than 0 at any point
        // before we reach initial start, it means no
        // circular tour is possible
        if (curr_petrol < 0) {
            return -1;
        }
    }
 
    // If we have successfully reached intial_start, it
    // means can get a circular tour from final_start, hence
    // return it
    return start;
}
// Driver code
int main()
{
    petrolPump arr[] = { { 6, 4 }, { 3, 6 }, { 7, 3 } };
 
    int n = sizeof(arr) / sizeof(arr[0]);
    int start = printTour(arr, n);
 
    (start == -1) ? cout << "No solution"
                  : cout << "Start = " << start;
 
    return 0;
}
 
Output
Start = 2
Time Complexity: O(N)
Auxiliary Space: O(1)

Using Single Loop:

The idea is similar to the above approach. 

Here we will use another variable to substitute the extra loop from start till the latest found start point. The variable will store the sum of utilized petrol from 0 till the latest start petrol pump.


// C++ program to find circular tour for a truck
#include <bits/stdc++.h>
using namespace std;
 
// A petrol pump has petrol and distance to next petrol pump
class petrolPump {
public:
    int petrol;
    int distance;
};
 
// The function returns starting point if there is a
// possible solution, otherwise returns -1
int printTour(petrolPump p[], int n)
{
    // deficit is used to store the value of the capacity as
    // soon as the value of capacity becomes negative so as
    // not to traverse the array twice in order to get the
    // solution
    int start = 0, deficit = 0;
    int capacity = 0;
    for (int i = 0; i < n; i++) {
        capacity += p[i].petrol - p[i].distance;
        if (capacity < 0) {
// If this particular step is not done then the between steps would be redundant
            start = i + 1;
            deficit += capacity;
            capacity = 0;
        }
    }
    return (capacity + deficit >= 0) ? start : -1;
}
// Driver code
int main()
{
    petrolPump arr[] = { { 6, 4 }, { 3, 6 }, { 7, 3 } };
 
    int n = sizeof(arr) / sizeof(arr[0]);
    int start = printTour(arr, n);
 
    (start == -1) ? cout << "No solution"
                  : cout << "Start = " << start;
 
    return 0;
}
Output
Start = 2
Time Complexity: O(N)
Auxiliary Space: O(1) 

Minimum time required to rot all oranges	
-----------------------------------------------
Given a matrix of dimension M * N where each cell in the matrix can have values 0, 1 or 2 which has the following meaning:  

0: Empty cell
1: Cells have fresh oranges
2: Cells have rotten oranges
Determine what is the minimum time required so that all the oranges become rotten. A rotten orange at index (i,j ) can rot other fresh oranges which are its neighbours (up, down, left and right). If it is impossible to rot every orange then simply return -1.

Examples: 

Input:  arr[][C] = { {2, 1, 0, 2, 1}, {1, 0, 1, 2, 1}, {1, 0, 0, 2, 1}};
Output: 2
Explanation: At 0th time frame:
{2, 1, 0, 2, 1}
{1, 0, 1, 2, 1}
{1, 0, 0, 2, 1}
At 1st time frame:
{2, 2, 0, 2, 2}
{2, 0, 2, 2, 2}
{1, 0, 0, 2, 2}
At 2nd time frame:
{2, 2, 0, 2, 2}
{2, 0, 2, 2, 2}
{2, 0, 0, 2, 2}


Input:  arr[][C] = { {2, 1, 0, 2, 1}, {0, 0, 1, 2, 1}, {1, 0, 0, 2, 1}}
Output: -1
Explanation: At 0th time frame:
{2, 1, 0, 2, 1}
{0, 0, 1, 2, 1}
{1, 0, 0, 2, 1}
At 1st time frame:
{2, 2, 0, 2, 2}
{0, 0, 2, 2, 2}
{1, 0, 0, 2, 2}
At 2nd time frame:
{2, 2, 0, 2, 2}
{0, 0, 2, 2, 2}
{1, 0, 0, 2, 2}
The 1 at the bottom left corner of the matrix is never rotten.

Naive Approach:  

The idea is very basic. Traverse through all oranges in multiple rounds. In every round, rot the oranges to the adjacent position of oranges that were rotten in the last round.

Follow the steps below to solve the problem:

Create a variable no = 2 and changed = false.
Run a loop until there is no cell of the matrix which is changed in an iteration.
Run a nested loop and traverse the matrix: 
If the element of the matrix is equal to no then assign the adjacent elements to no + 1 if the adjacent element’s value is equal to 1, i.e. not rotten, and update changed to true.
Traverse the matrix and check if there is any cell that is 1. 
If 1 is present return -1
Else return no – 2.

// C++ program to rot all oranges when u can move
// in all the four direction from a rotten orange
#include <bits/stdc++.h>
using namespace std;
 
const int R = 3;
const int C = 5;
 
// Check if i, j is under the array limits of row and column
bool issafe(int i, int j)
{
    if (i >= 0 && i < R && j >= 0 && j < C)
        return true;
    return false;
}
 
int rotOranges(int v[R][C])
{
    bool changed = false;
    int no = 2;
    while (true) {
        for (int i = 0; i < R; i++) {
            for (int j = 0; j < C; j++) {
 
                // Rot all other oranges present at
                // (i+1, j), (i, j-1), (i, j+1), (i-1, j)
                if (v[i][j] == no) {
                    if (issafe(i + 1, j)
                        && v[i + 1][j] == 1) {
                        v[i + 1][j] = v[i][j] + 1;
                        changed = true;
                    }
                    if (issafe(i, j + 1)
                        && v[i][j + 1] == 1) {
                        v[i][j + 1] = v[i][j] + 1;
                        changed = true;
                    }
                    if (issafe(i - 1, j)
                        && v[i - 1][j] == 1) {
                        v[i - 1][j] = v[i][j] + 1;
                        changed = true;
                    }
                    if (issafe(i, j - 1)
                        && v[i][j - 1] == 1) {
                        v[i][j - 1] = v[i][j] + 1;
                        changed = true;
                    }
                }
            }
        }
 
        // if no rotten orange found it means all
        // oranges rottened now
        if (!changed)
            break;
        changed = false;
        no++;
    }
 
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
 
            // if any orange is found to be
            // not rotten then ans is not possible
            if (v[i][j] == 1)
                return -1;
        }
    }
 
    // Because initial value for a rotten
    // orange was 2
    return no - 2;
}
 
// Driver function
int main()
{
 
    int v[R][C] = { { 2, 1, 0, 2, 1 },
                    { 1, 0, 1, 2, 1 },
                    { 1, 0, 0, 2, 1 } };
 
    cout << "Max time incurred: " << rotOranges(v);
 
    return 0;
}
Output
Max time incurred: 2
Time Complexity: O((R*C) * (R *C)), 
The matrix needs to be traversed again and again until there is no change in the matrix, that can happen max(R *C)/2 times. 
So time complexity is O((R * C) * (R *C)).
Auxiliary Space: O(1), No extra space is required.

Using Breadth First Search:

The idea is to use Breadth First Search. The condition of oranges getting rotten is when they come in contact with other rotten oranges. This is similar to a breadth-first search where the graph is divided into layers or circles and the search is done from lower or closer layers to deeper or higher layers. 

In the previous approach, the idea was based on BFS but the implementation was poor and inefficient. To find the elements whose values are no the whole matrix had to be traversed. So time can be reduced by using this efficient approach of BFS.  

Follow the steps below to solve the problem:

Create an empty queue Q. 
Find all rotten oranges and enqueue them to Q. Also, enqueue a delimiter to indicate the beginning of the next time frame.
Run a loop While Q is not empty and do the following while the delimiter in Q is not reached
Dequeue an orange from the queue, and rot all adjacent oranges. 
While rotting the adjacent, make sure that the time frame is incremented only once. And the time frame is not incremented if there are no adjacent oranges.
Dequeue the old delimiter and enqueue a new delimiter. The oranges rotten in the previous time frame lie between the two delimiters.
Return the last time frame.
Illustration:


























// C++ program to find minimum time required to make all oranges rotten
#include <bits/stdc++.h>
#define R 3
#define C 5
using namespace std;
 
// function to check whether a cell is valid / invalid
bool isvalid(int i, int j)
{
    return (i >= 0 && j >= 0 && i < R && j < C);
}
 
// structure for storing coordinates of the cell
struct ele {
    int x, y;
};
 
// Function to check whether the cell is delimiter
// which is (-1, -1)
bool isdelim(ele temp)
{
    return (temp.x == -1 && temp.y == -1);
}
 
// Function to check whether there is still a fresh
// orange remaining
bool checkall(int arr[][C])
{
    for (int i = 0; i < R; i++)
        for (int j = 0; j < C; j++)
            if (arr[i][j] == 1)
                return true;
    return false;
}
 
// This function finds if it is possible to rot all oranges
// or not. If possible, then it returns minimum time
// required to rot all, otherwise returns -1
int rotOranges(int arr[][C])
{
    // Create a queue of cells
    queue<ele> Q;
    ele temp;
    int ans = 0;
 
    // Store all the cells having rotten orange in first
    // time frame
    for (int i = 0; i < R; i++) {
        for (int j = 0; j < C; j++) {
            if (arr[i][j] == 2) {
                temp.x = i;
                temp.y = j;
                Q.push(temp);
            }
        }
    }
 
    // Separate these rotten oranges from the oranges which
    // will rotten due the oranges in first time frame using
    // delimiter which is (-1, -1)
    temp.x = -1;
    temp.y = -1;
    Q.push(temp);
 
    // Process the grid while there are rotten oranges in
    // the Queue
    while (!Q.empty()) {
        // This flag is used to determine whether even a
        // single fresh orange gets rotten due to rotten
        // oranges in current time frame so we can increase
        // the count of the required time.
        bool flag = false;
 
        // Process all the rotten oranges in current time
        // frame.
        while (!isdelim(Q.front())) {
            temp = Q.front();
 
            // Check right adjacent cell that if it can be
            // rotten
            if (isvalid(temp.x + 1, temp.y)
                && arr[temp.x + 1][temp.y] == 1) {
                // if this is the first orange to get
                // rotten, increase count and set the flag.
                if (!flag)
                    ans++, flag = true;
 
                // Make the orange rotten
                arr[temp.x + 1][temp.y] = 2;
 
                // push the adjacent orange to Queue
                temp.x++;
                Q.push(temp);
 
                temp.x--; // Move back to current cell
            }
 
            // Check left adjacent cell that if it can be
            // rotten
            if (isvalid(temp.x - 1, temp.y)
                && arr[temp.x - 1][temp.y] == 1) {
                if (!flag)
                    ans++, flag = true;
                arr[temp.x - 1][temp.y] = 2;
                temp.x--;
                Q.push(temp); // push this cell to Queue
                temp.x++;
            }
 
            // Check top adjacent cell that if it can be
            // rotten
            if (isvalid(temp.x, temp.y + 1)
                && arr[temp.x][temp.y + 1] == 1) {
                if (!flag)
                    ans++, flag = true;
                arr[temp.x][temp.y + 1] = 2;
                temp.y++;
                Q.push(temp); // Push this cell to Queue
                temp.y--;
            }
 
            // Check bottom adjacent cell if it can be
            // rotten
            if (isvalid(temp.x, temp.y - 1)
                && arr[temp.x][temp.y - 1] == 1) {
                if (!flag)
                    ans++, flag = true;
                arr[temp.x][temp.y - 1] = 2;
                temp.y--;
                Q.push(temp); // push this cell to Queue
            }
 
            Q.pop();
        }
 
        // Pop the delimiter
        Q.pop();
 
        // If oranges were rotten in current frame then
        // separate the rotten oranges using delimiter for
        // the next frame for processing.
        if (!Q.empty()) {
            temp.x = -1;
            temp.y = -1;
            Q.push(temp);
        }
 
// If Queue was empty then no rotten oranges left to process so exit
    }
 
 // Return -1 if all arranges could not rot, otherwise return ans.
    return (checkall(arr)) ? -1 : ans;
}
 
// Driver program
int main()
{
    int arr[][C] = { { 2, 1, 0, 2, 1 },
                     { 1, 0, 1, 2, 1 },
                     { 1, 0, 0, 2, 1 } };
    int ans = rotOranges(arr);
    if (ans == -1)
        cout << "All oranges cannot rotn";
    else
        cout << "Time required for all oranges to rot => "
             << ans << endl;
    return 0;
}
Output
Time required for all oranges to rot => 2
Time Complexity: O( R *C), Each element of the matrix can be inserted into the queue only once so the upper bound of iteration is O(R*C)
Auxiliary Space: O(R*C), To store the elements in a queue.

Distance of nearest cell having 1 in a binary matrix	
------------------------------------------------------------
Given a binary matrix of N x M, containing at least a value 1. The task is to find the distance of the nearest 1 in the matrix for each cell. The distance is calculated as |i1 – i2| + |j1 – j2|, where i1, j1 are the row number and column number of the current cell, and i2, j2 are the row number and column number of the nearest cell having value 1

Examples: 

Input: N = 3, M = 4
mat[][] = { {0, 0, 0, 1}, {0, 0, 1, 1}, {0, 1, 1, 0} }
Output: 
3 2 1 0
2 1 0 0
1 0 0 1
Explanation: For cell at (0, 0), nearest 1 is at (0, 3).
So distance = (0 – 0) + (3 – 0) = 3.
Similarly, all the distance can be calculated

Input: N = 3, M = 3
mat[][] = { {1, 0, 0}, {0, 0, 1}, {0, 1, 1} }
Output:  
0 1 1
1 1 0
1 0 0 
Explanation:  For cell at (0, 1), nearest 1 is at (0, 0). 
So distance is 1. Similarly, all the distance can be calculated.

Naive Approach: To solve the problem follow the below idea:

The idea is to traverse the matrix for each cell and find the minimum distance, To find the minimum distance traverse the matrix and find the cell which contains 1 and calculate the distance between two cells and store the minimum distance

Follow the given steps to solve the problem:

Traverse the matrix from start to end (using two nested loops)
For every element find the closest element which contains 1. 
To find the closest element traverse the matrix and find the minimum distance
Fill the minimum distance in the matrix.
Return the matrix filled with the distance values as the required answer.

// C++ program to find distance of nearest
// cell having 1 in a binary matrix.
#include <bits/stdc++.h>
#define N 3
#define M 4
using namespace std;
 
// Print the distance of nearest cell
// having 1 for each cell.
void printDistance(int mat[N][M])
{
    int ans[N][M];
 
    // Initialize the answer matrix with INT_MAX.
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++)
            ans[i][j] = INT_MAX;
 
    // For each cell
    for (int i = 0; i < N; i++)
        for (int j = 0; j < M; j++) {
            // Traversing the whole matrix
            // to find the minimum distance.
            for (int k = 0; k < N; k++)
                for (int l = 0; l < M; l++) {
                    // If cell contain 1, check
                    // for minimum distance.
                    if (mat[k][l] == 1)
                        ans[i][j]
                            = min(ans[i][j],
                                  abs(i - k) + abs(j - l));
                }
        }
 
    // Printing the answer.
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++)
            cout << ans[i][j] << " ";
 
        cout << endl;
    }
}
 
// Driver code
int main()
{
    int mat[N][M] = { 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0 };
 
      // Function call
    printDistance(mat);
 
    return 0;
}
Output
3 2 1 0 
2 1 0 0 
1 0 0 1 
Time Complexity: O(N2 * M2). For every element in the matrix, the matrix is traversed and there are N*M elements.
Auxiliary Space: O(N * M)

Using the BFS method:
To solve the problem follow the below idea:

The idea is to use multisource Breadth-First Search. Consider each cell as a node and each boundary between any two adjacent cells be an edge. Number each cell from 1 to N*M. Now, push all the nodes whose corresponding cell value is 1 in the matrix in the queue. Apply BFS using this queue to find the minimum distance of the adjacent node

Follow the given steps to solve the problem:

Create a graph with values assigned from 1 to M*N to all vertices. The purpose is to store position and adjacent information.
Create an empty queue.
Traverse all matrix elements and insert positions of all 1s in the queue.
Now do a BFS traversal of the graph using the above-created queue.
Run a loop till the size of the queue is greater than 0 then extract the front node of the queue and remove it and insert all its adjacent and unmarked elements. 
Update the minimum distance as the distance of the current node +1 and insert the element in the queue.
Return the matrix containing the distances as the required answer.

// C++ program to find distance of nearest
// cell having 1 in a binary matrix.
#include <bits/stdc++.h>
#define MAX 500
#define N 3
#define M 4
using namespace std;
 
// Making a class of graph with bfs function.
class graph {
private:
    vector<int> g[MAX];
    int n, m;
 
public:
    graph(int a, int b)
    {
        n = a;
        m = b;
    }
 
    // Function to create graph with N*M nodes
    // considering each cell as a node and each
    // boundary as an edge.
    void createGraph()
    {
        int k = 1; // A number to be assigned to a cell
 
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= m; j++) {
                // If last row, then add edge on right side.
                if (i == n) {
                    // If not bottom right cell.
                    if (j != m) {
                        g[k].push_back(k + 1);
                        g[k + 1].push_back(k);
                    }
                }
 
                // If last column, then add edge toward
                // down.
                else if (j == m) {
                    g[k].push_back(k + m);
                    g[k + m].push_back(k);
                }
 
                // Else makes an edge in all four
                // directions.
                else {
                    g[k].push_back(k + 1);
                    g[k + 1].push_back(k);
                    g[k].push_back(k + m);
                    g[k + m].push_back(k);
                }
 
                k++;
            }
        }
    }
 
    // BFS function to find minimum distance
    void bfs(bool visit[], int dist[], queue<int> q)
    {
        while (!q.empty()) {
            int temp = q.front();
            q.pop();
 
            for (int i = 0; i < g[temp].size(); i++) {
                if (visit[g[temp][i]] != 1) {
                    dist[g[temp][i]] = min(dist[g[temp][i]],
                                           dist[temp] + 1);
 
                    q.push(g[temp][i]);
                    visit[g[temp][i]] = 1;
                }
            }
        }
    }
 
    // Printing the solution
    void print(int dist[])
    {
        for (int i = 1, c = 1; i <= n * m; i++, c++) {
            cout << dist[i] << " ";
 
            if (c % m == 0)
                cout << endl;
        }
    }
};
 
// Find minimum distance
void findMinDistance(bool mat[N][M])
{
    // Creating a graph with nodes values assigned
    // from 1 to N x M and matrix adjacent.
    graph g1(N, M);
    g1.createGraph();
 
    // To store minimum distance
    int dist[MAX];
 
    // To mark each node as visited or not in BFS
    bool visit[MAX] = { 0 };
 
    // Initialising the value of distance and visit.
    for (int i = 1; i <= M * N; i++) {
        dist[i] = INT_MAX;
        visit[i] = 0;
    }
 
    // Inserting nodes whose value in matrix
    // is 1 in the queue.
    int k = 1;
    queue<int> q;
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < M; j++) {
            if (mat[i][j] == 1) {
                dist[k] = 0;
                visit[k] = 1;
                q.push(k);
            }
            k++;
        }
    }
 
    // Calling for Bfs with given Queue.
    g1.bfs(visit, dist, q);
 
    // Printing the solution.
    g1.print(dist);
}
 
// Driver code
int main()
{
    bool mat[N][M] = { 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0 };
 
      // Function call
    findMinDistance(mat);
 
    return 0;
}
Output
3 2 1 0 
2 1 0 0 
1 0 0 1 
Time Complexity: O(N*M). In BFS traversal every element is traversed only once so the time Complexity is O(M*N).
Space Complexity: O(M*N). To store every element in the matrix O(M*N) space is required.

First negative integer in every window of size “k”	
---------------------------------------------------------
Given an array and a positive integer k, find the first negative integer for each window(contiguous subarray) of size k. If a window does not contain a negative integer, then print 0 for that window.

Examples:  

Input : arr[] = {-8, 2, 3, -6, 10}, k = 2
Output : -8 0 -6 -6

First negative integer for each window of size k
{-8, 2} = -8
{2, 3} = 0 (does not contain a negative integer)
{3, -6} = -6
{-6, 10} = -6

Input : arr[] = {12, -1, -7, 8, -15, 30, 16, 28} , k = 3
Output : -1 -1 -7 -15 -15 0

Run two loops. In the outer loop, take all subarrays(windows) of size k. In the inner loop, get the first negative integer of the current subarray(window).

// C++ implementation to find the first negative
// integer in every window of size k
#include <bits/stdc++.h>
using namespace std;
  
// function to find the first negative
// integer in every window of size k
void printFirstNegativeInteger(int arr[], int n, int k)
{
    // flag to check whether window contains
    // a negative integer or not
    bool flag;
     
    // Loop for each subarray(window) of size k
    for (int i = 0; i<(n-k+1); i++)          
    {
        flag = false;
 
        // traverse through the current window
        for (int j = 0; j<k; j++)
        {
            // if a negative integer is found, then
            // it is the first negative integer for
            // current window. Print it, set the flag
            // and break
            if (arr[i+j] < 0)
            {
                cout << arr[i+j] << " ";
                flag = true;
                break;
            }
        }
         
        // if the current window does not
        // contain a negative integer
        if (!flag)
            cout << "0" << " ";
    }   
}
  
// Driver program to test above functions
int main()
{
    int arr[] = {12, -1, -7, 8, -15, 30, 16, 28};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;
    printFirstNegativeInteger(arr, n, k);
    return 0;
}
Output
-1 -1 -7 -15 -15 0 
Time Complexity : The outer loop runs n-k+1 times and the inner loop runs k times for every iteration of outer loop. So time complexity is O((n-k+1)*k) which can also be written as O(nk) when k is comparatively much smaller than n, otherwise when k tends to reach n, complexity becomes O(k). 
Auxiliary Space: O(1) as it is using constant space for variables

Approach 2: Efficient Approach
We create a Dequeue, Di of capacity k, that stores only useful elements of the current window of k elements. An element is useful if it is in the current window and it is a negative integer. We process all array elements one by one and maintain Di to contain useful elements of current window and these useful elements are all negative integers. For a particular window, if Di is not empty then the element at front of the Di is the first negative integer for that window, else that window does not contain a negative integer.

It is a variation of the problem of Sliding Window Maximum. 

// C++ implementation to find the first negative
// integer in every window of size k
#include <bits/stdc++.h>
using namespace std;
  
// function to find the first negative
// integer in every window of size k
void printFirstNegativeInteger(int arr[], int n, int k)
{
    // A Double Ended Queue, Di that will store indexes of
    // useful array elements for the current window of size k.
    // The useful elements are all negative integers.
    deque<int>  Di;
  
    /* Process first k (or first window) elements of array */
    int i;
    for (i = 0; i < k; i++)
        // Add current element at the rear of Di
        // if it is a negative integer
        if (arr[i] < 0)
            Di.push_back(i);
     
    // Process rest of the elements, i.e., from arr[k] to arr[n-1]
    for ( ; i < n; i++)
    {
        // if Di is not empty then the element at the
        // front of the queue is the first negative integer
        // of the previous window
        if (!Di.empty())
            cout << arr[Di.front()] << " ";
         
        // else the window does not have a
        // negative integer
        else
            cout << "0" << " ";
  
        // Remove the elements which are out of this window
        while ( (!Di.empty()) && Di.front() < (i - k + 1))
            Di.pop_front();  // Remove from front of queue
  
        // Add current element at the rear of Di
        // if it is a negative integer
        if (arr[i] < 0)
            Di.push_back(i);
    }
  
    // Print the first negative
    // integer of last window
    if (!Di.empty())
           cout << arr[Di.front()] << " ";
    else
        cout << "0" << " ";      
     
}
  
// Driver program to test above functions
int main()
{
    int arr[] = {12, -1, -7, 8, -15, 30, 16, 28};
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;
    printFirstNegativeInteger(arr, n, k);
    return 0;
}
Output
-1 -1 -7 -15 -15 0 
Time Complexity: O(n) 
Auxiliary Space: O(k)

Optimized Approach:: It is also possible to accomplish this with constant space. The idea is to have a variable firstNegativeIndex to keep track of the first negative element in the k sized window. At every iteration, we skip the elements which no longer fall under the current k size window (firstNegativeIndex <= i – k) as well as the non-negative elements(zero or positive). 

// C++ code for First negative integer
// in every window of size k
#include <iostream>
using namespace std;
 
void printFirstNegativeInteger(int arr[], int k, int n)
{
    int firstNegativeIndex = 0;
    int firstNegativeElement;
 
    for (int i = k - 1; i < n; i++) {
 
        // skip out of window and positive elements
        while ((firstNegativeIndex < i)
               && (firstNegativeIndex <= i - k
                   || arr[firstNegativeIndex] >= 0)) {
            firstNegativeIndex++;
        }
 
        // check if a negative element is found, otherwise
        // use 0
        if (arr[firstNegativeIndex] < 0) {
            firstNegativeElement = arr[firstNegativeIndex];
        }
        else {
            firstNegativeElement = 0;
        }
        cout << firstNegativeElement << " ";
    }
}
 
// Driver code
int main()
{
    int arr[] = { 12, -1, -7, 8, -15, 30, 16, 28 };
    int n = sizeof(arr) / sizeof(arr[0]);
    int k = 3;
    printFirstNegativeInteger(arr, k, n);
}
Output
-1 -1 -7 -15 -15 0 
Time Complexity: O(n) 
Auxiliary Space: O(1)

Check if all levels of two trees are anagrams or not.	
----------------------------------------------------------
Given two binary trees, we have to check if each of their levels are anagrams of each other or not. 
Example: 

Tree 1:
Level 0 : 1
Level 1 : 3, 2
Level 2 : 5, 4

Tree 2:
Level 0 : 1
Level 1 : 2, 3
Level 2 : 4, 5
As we can clearly see all the levels of above two binary trees are anagrams of each other, hence return true.

Naive Approach: Below is the step by step explanation of the naive approach to do this: 
 

Write a recursive program for level order traversal of a tree.
Traverse each level of both the trees one by one and store the result of traversals in 2 different vectors, one for each tree.
Sort both the vectors and compare them iteratively for each level, if they are same for each level then return true else return false.
Time Complexity: O(n^2), where n is the number of nodes.
Efficient Approach: 
We traverse both trees simultaneously level by level. We store each level both trees in vectors (or array). To check if two vectors are anagram or not, we sort both and then compare.
Time Complexity: O(nlogn), where n is the number of nodes. 
 


/* Iterative program to check if two trees are level by level anagram. */
#include <bits/stdc++.h>
using namespace std;
 
// A Binary Tree Node
struct Node
{
    struct Node *left, *right;
    int data;
};
 
// Returns true if trees with root1 and root2
// are level by level anagram, else returns false.
bool areAnagrams(Node *root1, Node *root2)
{
    // Base Cases
    if (root1 == NULL && root2 == NULL)
        return true;
    if (root1 == NULL || root2 == NULL)
        return false;
 
    // start level order traversal of two trees
    // using two queues.
    queue<Node *> q1, q2;
    q1.push(root1);
    q2.push(root2);
 
    while (1)
    {
        // n1 (queue size) indicates number of Nodes
        // at current level in first tree and n2 indicates
        // number of nodes in current level of second tree.
        int n1 = q1.size(), n2 = q2.size();
 
        // If n1 and n2 are different
        if (n1 != n2)
            return false;
 
        // If level order traversal is over 
        if (n1 == 0)
            break;
 
        // Dequeue all Nodes of current level and
        // Enqueue all Nodes of next level
        vector<int> curr_level1, curr_level2;
        while (n1 > 0)
        {
            Node *node1 = q1.front();
            q1.pop();
            if (node1->left != NULL)
                q1.push(node1->left);
            if (node1->right != NULL)
                q1.push(node1->right);
            n1--;
 
            Node *node2 = q2.front();
            q2.pop();
            if (node2->left != NULL)
                q2.push(node2->left);
            if (node2->right != NULL)
                q2.push(node2->right);
 
            curr_level1.push_back(node1->data);
            curr_level2.push_back(node2->data);
        }
 
        // Check if nodes of current levels are
        // anagrams or not.
        sort(curr_level1.begin(), curr_level1.end());
        sort(curr_level2.begin(), curr_level2.end());
        if (curr_level1 != curr_level2)
            return false;
    }
 
    return true;
}
 
// Utility function to create a new tree Node
Node* newNode(int data)
{
    Node *temp = new Node;
    temp->data = data;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Driver program to test above functions
int main()
{
    // Constructing both the trees.
    struct Node* root1 = newNode(1);
    root1->left = newNode(3);
    root1->right = newNode(2);
    root1->right->left = newNode(5);
    root1->right->right = newNode(4);
 
    struct Node* root2 = newNode(1);
    root2->left = newNode(2);
    root2->right = newNode(3);
    root2->left->left = newNode(4);
    root2->left->right = newNode(5);
 
    areAnagrams(root1, root2)? cout << "Yes" : cout << "No";
    return 0;
}
Output
Yes
Note: In the above program we are comparing the vectors storing each level of a tree directly using not equal to function ‘ != ‘ which compares the vectors first on the basis of their size and then on the basis of their content, hence saving our work of iteratively comparing the vectors.
Efficient Approach:

We can solve the problem in O(n) time complexity by using Hash tables during level order traversal. The idea is to do a level order traversal and in each level check whether the level is an anagram with help of hash tables.


/* Iterative program to check if two trees are level
  by level anagram. */
#include <bits/stdc++.h>
using namespace std;
 
// A Binary Tree Node
struct Node {
    struct Node *left, *right;
    int data;
};
 
// Returns true if trees with root1 and root2
// are level by level anagram, else returns false.
bool areAnagrams(Node* root1, Node* root2)
{
    // Base Cases
    if (root1 == NULL && root2 == NULL)
        return true;
    if (root1 == NULL || root2 == NULL)
        return false;
 
    // start level order traversal of two trees
    // using two queues.
    queue<Node*> q1, q2;
    q1.push(root1);
    q2.push(root2);
 
    // Hashmap to store the elements that occur in each
    // level.
    unordered_map<int, int> m;
 
    while (!q1.empty() && !q2.empty()) {
        // n1 (queue size) indicates number of Nodes
        // at current level in first tree and n2 indicates
        // number of nodes in current level of second tree.
        int n1 = q1.size(), n2 = q2.size();
 
        // If n1 and n2 are different
        if (n1 != n2)
            return false;
 
        // If level order traversal is over
        if (n1 == 0)
            break;
 
        // Dequeue all Nodes of current level and
        // Enqueue all Nodes of next level
        while (n1--) {
            Node* node1 = q1.front();
            q1.pop();
 
            // Insert element into hashmap
            m[node1->data]++;
 
            // Insert left and right nodes into queue if
            // exists.
            if (node1->left != NULL)
                q1.push(node1->left);
            if (node1->right != NULL)
                q1.push(node1->right);
        }
 
        while (n2--) {
            Node* node2 = q2.front();
            q2.pop();
 
            // if element from second tree isn't present in
            // the first tree of same level then it can't be
            // an anagram.
            if (m.find(node2->data) == m.end())
                return false;
 
            // Reduce frequency of element if present else
            // adds it element to hash map with negative
            // frequency.
            m[node2->data]--;
 
            // If frequency of the element becomes zero then
            // remove the element from hashmap.
            if (m[node2->data] == 0)
                m.erase(node2->data);
 
            // Insert left and right nodes into queue if
            // exists.
            if (node2->left != NULL)
                q2.push(node2->left);
            if (node2->right != NULL)
                q2.push(node2->right);
        }
 
        // If nodes of current levels are anagrams the
        // hashmap wouldn't contain any elements.
        if (m.size() > 0)
            return false;
    }
  if(q1.empty() && q2.empty())
    return true;
  return false;
}
 
// Utility function to create a new tree Node
Node* newNode(int data)
{
    Node* temp = new Node;
    temp->data = data;
    temp->left = temp->right = NULL;
    return temp;
}
 
// Driver program to test above functions
int main()
{
    // Constructing both the trees.
    struct Node* root1 = newNode(1);
    root1->left = newNode(3);
    root1->right = newNode(2);
    root1->right->left = newNode(5);
    root1->right->right = newNode(4);
 
    struct Node* root2 = newNode(1);
    root2->left = newNode(2);
    root2->right = newNode(3);
    root2->left->left = newNode(4);
    root2->left->right = newNode(5);
 
    areAnagrams(root1, root2) ? cout << "Yes"
                              : cout << "No";
    return 0;
}
 
Output
Yes
Time complexity: O(N), where N is maximum number of nodes in either of the trees.

Sum of minimum and maximum elements of all subarrays of size “k”.	
--------------------------------------------------------------------
Given an array of both positive and negative integers, the task is to compute sum of minimum and maximum elements of all sub-array of size k.

Examples: 

Input : arr[] = {2, 5, -1, 7, -3, -1, -2}  
        K = 4
Output : 18
Explanation : Subarrays of size 4 are : 
     {2, 5, -1, 7},   min + max = -1 + 7 = 6
     {5, -1, 7, -3},  min + max = -3 + 7 = 4      
     {-1, 7, -3, -1}, min + max = -3 + 7 = 4
     {7, -3, -1, -2}, min + max = -3 + 7 = 4   
     
     Missing sub arrays - 
     
     {2, -1, 7, -3}
     {2, 7, -3, -1}
     {2, -3, -1, -2}
     {5, 7, -3, -1}
     {5, -3, -1, -2}
     and few more -- why these were not considered??
     Considering missing arrays result coming as 27
     
     Sum of all min & max = 6 + 4 + 4 + 4 
                          = 18  

Method 1 (Simple): Run two loops to generate all subarrays of size k and find maximum and minimum values. Finally, return sum of all maximum and minimum elements. 
Time taken by this solution is O(n*k).

Method 2 (Efficient using Dequeue): The idea is to use Dequeue data structure and sliding window concept. We create two empty double-ended queues of size k (‘S’ , ‘G’) that only store indices of elements of current window that are not useless. An element is useless if it can not be maximum or minimum of next subarrays. 

 a) In deque 'G', we maintain decreasing order of 
    values from front to rear
 b) In deque 'S', we maintain increasing order of 
    values from front to rear

1) First window size K
  1.1) For deque 'G', if current element is greater 
       than rear end element, we remove rear while 
       current is greater.
  1.2) For deque 'S', if current element is smaller 
       than rear end element, we just pop it while 
       current is smaller.
  1.3) insert current element in both deque 'G' 'S'

2) After step 1, front of 'G' contains maximum element
   of first window and front of 'S' contains minimum 
   element of first window. Remaining elements of G
   and S may store maximum/minimum for subsequent 
   windows.

3) After that we do traversal for rest array elements.
  3.1) Front element of deque 'G' is greatest and 'S' 
       is smallest element of previous window 
  3.2) Remove all elements which are out of this 
       window [remove element at front of queue ]
  3.3) Repeat steps 1.1 , 1.2 ,1.3 

4) Return sum of minimum and maximum element of all 
   sub-array size k.

// C++ program to find sum of all minimum and maximum elements Of Sub-array Size k.
#include<bits/stdc++.h>
using namespace std;
 
// Returns sum of min and max element of all subarrays
// of size k
int SumOfKsubArray(int arr[] , int n , int k)
{
    int sum = 0;  // Initialize result
 
    // The queue will store indexes of useful elements
    // in every window
    // In deque 'G' we maintain decreasing order of
    // values from front to rear
    // In deque 'S' we  maintain increasing order of
    // values from front to rear
    deque< int > S(k), G(k);
 
    // Process first window of size K
    int i = 0;
    for (i = 0; i < k; i++)
    {
        // Remove all previous greater elements
        // that are useless.
        while ( (!S.empty()) && arr[S.back()] >= arr[i])
            S.pop_back(); // Remove from rear
 
        // Remove all previous smaller that are elements
        // are useless.
        while ( (!G.empty()) && arr[G.back()] <= arr[i])
            G.pop_back(); // Remove from rear
 
        // Add current element at rear of both deque
        G.push_back(i);
        S.push_back(i);
    }
 
    // Process rest of the Array elements
    for (  ; i < n; i++ )
    {
        // Element at the front of the deque 'G' & 'S'
        // is the largest and smallest
        // element of previous window respectively
        sum += arr[S.front()] + arr[G.front()];
 
        // Remove all elements which are out of this
        // window
        while ( !S.empty() && S.front() <= i - k)
            S.pop_front();
        while ( !G.empty() && G.front() <= i - k)
            G.pop_front();
 
        // remove all previous greater element that are
        // useless
        while ( (!S.empty()) && arr[S.back()] >= arr[i])
            S.pop_back(); // Remove from rear
 
        // remove all previous smaller that are elements
        // are useless
        while ( (!G.empty()) && arr[G.back()] <= arr[i])
            G.pop_back(); // Remove from rear
 
        // Add current element at rear of both deque
        G.push_back(i);
        S.push_back(i);
    }
 
    // Sum of minimum and maximum element of last window
    sum += arr[S.front()] + arr[G.front()];
 
    return sum;
}
 
// Driver program to test above functions
int main()
{
    int arr[] = {2, 5, -1, 7, -3, -1, -2} ;
    int n = sizeof(arr)/sizeof(arr[0]);
    int k = 3;
    cout << SumOfKsubArray(arr, n, k) ;
    return 0;
}
Output
14
Time Complexity: O(n)
Auxiliary Space: O(k)

Minimum sum of squares of character counts in a given string after removing “k” characters.	
--------------------------------------------------------------------------------------------
Given a string of lowercase alphabets and a number k, the task is to print the minimum value of the string after removal of ‘k’ characters. The value of a string is defined as the sum of squares of the count of each distinct character. 
For example consider the string “saideep”, here frequencies of characters are s-1, a-1, i-1, e-2, d-1, p-1 and value of the string is 1^2 + 1^2 + 1^2 + 1^2 + 1^2 + 2^2 = 9.
Expected Time Complexity: O(k*logn)

Examples: 

Input :  str = abccc, K = 1
Output :  6
Explanation: We remove c to get the value as 12 + 12 + 22

Input :  str = aaab, K = 2
Output :  2

One clear observation is that we need to remove character with highest frequency. One trick is the character ma
A Simple solution is to use sorting technique through all current highest frequency reduce up to k times. For After every reduce again sort frequency array. 

A Better Solution used to Priority Queue which has to the highest element on top. 

Initialize empty priority queue.
Count frequency of each character and Store into temp array.
Remove K characters which have highest frequency from queue.
Finally Count Sum of square of each element and return it.

// C++ program to find min sum of squares
// of characters after k removals
#include <bits/stdc++.h>
using namespace std;
 
const int MAX_CHAR = 26;
 
// Main Function to calculate min sum of
// squares of characters after k removals
int minStringValue(string str, int k)
{
    int l = str.length(); // find length of string
 
    // if K is greater than length of string
    // so reduced string will become 0
    if (k >= l)
        return 0;
 
    // Else find Frequency of each character and
    // store in an array
    int frequency[MAX_CHAR] = { 0 };
    for (int i = 0; i < l; i++)
        frequency[str[i] - 'a']++;
 
    // Push each char frequency into a priority_queue
    priority_queue<int> q;
    for (int i = 0; i < MAX_CHAR; i++)
        q.push(frequency[i]);
 
    // Removal of K characters
    while (k--) {
        // Get top element in priority_queue,
        // remove it. Decrement by 1 and again
        // push into priority_queue
        int temp = q.top();
        q.pop();
        temp = temp - 1;
        q.push(temp);
    }
 
    // After removal of K characters find sum
    // of squares of string Value
    int result = 0; // Initialize result
    while (!q.empty()) {
        int temp = q.top();
        result += temp * temp;
        q.pop();
    }
 
    return result;
}
 
// Driver Code
int main()
{
    string str = "abbccc"; // Input 1
    int k = 2;
    cout << minStringValue(str, k) << endl;
 
    str = "aaab"; // Input 2
    k = 2;
    cout << minStringValue(str, k);
 
    return 0;
}
Output
6
2
Time Complexity: O(k*logn)
Auxiliary Space: O(1) because constant size array and priority_queue are being used

Efficient Approach :

We can solve it in O(N) time complexity as we need to be greedy and always remove the characters of alphabets which are higher in frequency.

Example: Let str=”abbccc” and k=2 now, alphabetCount[1]=1;//for ‘a’ alphabetCount[2]=2;//for ‘b’ alphabetCount[3]=3;//for ‘c’ maximum=3 m[1]=1(only a occur 1 times) m[2]=1(only b occur 2 times) m[3]=1(only c occur 3 times) //k=2 maximum=3 so k=k-m[maximum]//k=k-1; so now one c got removes so frequencies are a=1,b=2,c=2; so as c’s frequency got decreased by one m[maximum] will be zero and m[maximum-1] will be increased by m[maximum] so update m[2]+=m[3], m[3]=0; also maximum gets decreased by one as it is guaranteed to exist frequency one less than maximum from above. m[1]=1 , m[2]=2 , m[3]=0 and k=1; now m[maximum](i.e m[2]=2>k) so we should partially remove remove one character of either b or c so m[1]=2 0,m[2]=1 ,m[3]=0 and k=0; so, (1*1)*2 + (2*2)*1 + (3*3)*0 = 6//ans

Implementation:

// C++ program to find min sum of squares
// of characters after k removals
#include <bits/stdc++.h>
using namespace std;
 
const int MAX_CHAR = 26;
 
// Main Function to calculate min sum of
// squares of characters after k removals
int minStringValue(string str, int k)
{
    int alphabetCount[MAX_CHAR]= {0};
 
    // Here the array stored frequency the number of
    // occurrences in string m[frequency]=number of alphabets
    // with frequency i.e, in our example abbccc m[1]=1(1
    // a's occur),m[2]=1(2 b's occur),m[3]=1(3 c'soccur)
    int m[str.length()] = { 0 };
   
    for (int i = 0; i < str.length(); i++) {
        alphabetCount[str[i] - 'a']++;
    }
    // Store the maximum
    int maximum = 0;
   
    for (int i = 0; i < MAX_CHAR; i++) {
        m[alphabetCount[i]]++;
        maximum = max(maximum, alphabetCount[i]);
    }
 
    while (k > 0) {
        int z = m[maximum];
        if (z <= k) {
            // Remove one occurrence of alphabet from each
            // with frequency as maximum.
            // So we will have k-z more remove operations to
            // perform as z is number of characters and we
            // perform one removal from each of the alphabet
            // with that frequency.
            k = k - z;
            // As we removed one occurrence from each the
            // alphabets will no longer have the frequency
            // of maximum their frequency will be decreased
            // by one so add these number of alphabets to
            // group with frequency one less than maximum.
            // Remove them from maximum count.
            m[maximum] = 0;
            // Add those to frequency one less.
            m[maximum - 1] += z;
            // new maximum will be one less.
            maximum--;
        }
        else {
            // if all the elements of that frequency cannot
            // be removed we should partially remove them.
            m[maximum] -= k;
            maximum--;
            m[maximum] += k;
            k = 0;
        }
    }
 
    int ans = 0;
    for (int i = 0; i < str.length(); i++) {
        //(square of frequency)*(number of
        // characters corresponding to that frequency)
        ans += (i * i) * m[i];
    }
 
    return ans;
}
 
// Driver Code
int main()
{
    string str = "abbccc"; // Input 1
    int k = 2;
    cout << minStringValue(str, k) << endl;
 
    str = "aaab"; // Input 2
    k = 2;
    cout << minStringValue(str, k);
 
    return 0;
}
 
Output
6
2
Time Complexity: O(N)
Space Complexity: O(N)

Queue based approach or first non-repeating character in a stream.	
--------------------------------------------------------------------
Given a stream of characters and we have to find first non repeating character each time a character is inserted to the stream. 

Examples: 

Input  : a a b c
Output : a -1 b b

Input  : a a c
Output : a -1 c

Approach:

Create a count array of size 26(assuming only lower case characters are present) and initialize it with zero.
Create a queue of char datatype.
Store each character in queue and increase its frequency in the hash array.
For every character of stream, we check front of the queue.
If the frequency of character at the front of queue is one, then that will be the first non-repeating character.
Else if frequency is more than 1, then we pop that element.
If queue became empty that means there are no non-repeating characters so we will print -1.

// C++ program for a Queue based approach
// to find first non-repeating character
#include <bits/stdc++.h>
using namespace std;
const int MAX_CHAR = 26;
 
// function to find first non repeating
// character of sa stream
void firstnonrepeating(char str[])
{
    queue<char> q;
    int charCount[MAX_CHAR] = { 0 };
 
    // traverse whole stream
    for (int i = 0; str[i]; i++) {
 
        // push each character in queue
        q.push(str[i]);
 
        // increment the frequency count
        charCount[str[i] - 'a']++;
 
        // check for the non repeating character
        while (!q.empty()) {
            if (charCount[q.front() - 'a'] > 1)
                q.pop();
            else {
                cout << q.front() << " ";
                break;
            }
        }
 
        if (q.empty())
            cout << -1 << " ";
    }
    cout << endl;
}
 
// Driver function
int main()
{
    char str[] = "aabc";
    firstnonrepeating(str);
    return 0;
}
Output: 
a -1 b b
Time complexity : O(n) 
Auxiliary Space : O(n)

Next Smaller Element	
--------------------------------
Given an array, print the Next Smaller Element (NSE) for every element. The NSE for an element x is the first smaller element on the right side of x in the array. Elements for which no smaller element exist (on the right side), consider NSE as -1. 

Examples: 

a) For any array, the rightmost element always has NSE as -1. 
b) For an array that is sorted in increasing order, all elements have NSE as -1. 
c) For the input array [4, 8, 5, 2, 25}, the NSE for each element is as follows.

Element         NSE
   4      -->    2
   8      -->    5
   5      -->    2
   2      -->   -1
   25     -->   -1
d) For the input array [13, 7, 6, 12}, the next smaller elements for each element are as follows.  

  Element        NSE
   13      -->    7
   7       -->    6
   6       -->   -1
   12      -->   -1

Method 1 (Simple):

Use two loops: The outer loop picks all the elements one by one. The inner loop looks for the first smaller element for the element picked by outer loop. If a smaller element is found then that element is printed as next, otherwise, -1 is printed.

// Simple C++ program to print next smaller elements in a given array
#include "bits/stdc++.h"
using namespace std;
 
/* prints element and NSE pair
for all elements of arr[] of size n */
void printNSE(int arr[], int n)
{
    int next, i, j;
    for (i = 0; i < n; i++)
    {
        next = -1;
        for (j = i + 1; j < n; j++)
        {
            if (arr[i] > arr[j])
            {
                next = arr[j];
                break;
            }
        }
        cout << arr[i] << " -- "
             << next << endl;
    }
}
 
// Driver Code
int main()
{
    int arr[]= {11, 13, 21, 3};
    int n = sizeof(arr) / sizeof(arr[0]);
    printNSE(arr, n);
    return 0;
}
 
Output
11 -- 3
13 -- 3
21 -- 3
3 -- -1
Time Complexity: O(N^2)     : The worst case occurs when all elements are sorted in increasing order.

Auxiliary Space: O(1):  As constant extra space is used

Method 2 (Using Segment Tree and Binary Search) 

This method is also pretty simple if one knows Segment trees and Binary Search. Lets consider an array a        and lets suppose NSE for a_{i}        is a_{j}       , we simply need to binary search for j        in range i + 1        to n - 1       . j        will be the first index k       , such that range minimum of elements from index i + 1        to k        (\forall k\in [i+1, n - 1]       ) is lesser than a_{i}       .

Example


#include <bits/stdc++.h>
using namespace std;
 
// Program to find next smaller element for all elements in
// an array, using segment tree and binary search
 
// --------Segment Tree Starts Here-----------------
 
vector<int> seg_tree;
 
// combine function for combining two nodes of the tree, in
// this case we need to take min of two
int combine(int a, int b) { return min(a, b); }
 
// build function, builds seg_tree based on vector parameter
// arr
void build(vector<int>& arr, int node, int tl, int tr)
{
    // if current range consists only of one element, then
    // node should be this element
    if (tl == tr) {
        seg_tree[node] = arr[tl];
    }
    else {
        // divide the build operations into two parts
        int tm = (tr - tl) / 2 + tl;
 
        build(arr, 2 * node, tl, tm);
        build(arr, 2 * node + 1, tm + 1, tr);
 
        // combine the results from two parts, and store it
        // into current node
        seg_tree[node] = combine(seg_tree[2 * node],
                                 seg_tree[2 * node + 1]);
    }
}
 
// query function, returns minimum in the range [l, r]
int query(int node, int tl, int tr, int l, int r)
{
    // if range is invalid, then return infinity
    if (l > r) {
        return INT32_MAX;
    }
 
    // if range completely aligns with a segment tree node,
    // then value of this node should be returned
    if (l == tl && r == tr) {
        return seg_tree[node];
    }
 
    // else divide the query into two parts
    int tm = (tr - tl) / 2 + tl;
 
    int q1 = query(2 * node, tl, tm, l, min(r, tm));
    int q2 = query(2 * node + 1, tm + 1, tr, max(l, tm + 1),
                   r);
 
    // and combine the results from the two parts and return
    // it
    return combine(q1, q2);
}
 
// --------Segment Tree Ends Here-----------------
 
void printNSE(vector<int> arr, int n)
{
    seg_tree = vector<int>(4 * n);
 
    // build segment tree initially
    build(arr, 1, 0, n - 1);
 
    int q, l, r, mid, ans;
    for (int i = 0; i < n; i++) {
        // binary search for ans in range [i + 1, n - 1],
        // initially ans is -1 representing there is no NSE
        // for this element
        l = i + 1;
        r = n - 1;
        ans = -1;
 
        while (l <= r) {
            mid = (r - l) / 2 + l;
            // q is the minimum element in range [l, mid]
            q = query(1, 0, n - 1, l, mid);
 
            // if the minimum element in range [l, mid] is
            // less than arr[i], then mid can be answer, we
            // mark it, and look for a better answer in left
            // half. Else if q is greater than arr[i], mid
            // can't be an answer, we should search in right
            // half
 
            if (q < arr[i]) {
                ans = arr[mid];
                r = mid - 1;
            }
            else {
                l = mid + 1;
            }
        }
 
        // print NSE for arr[i]
        cout << arr[i] << " ---> " << ans << "\n";
    }
}
 
// Driver program to test above functions
int main()
{
    vector<int> arr = { 11, 13, 21, 3 };
    printNSE(arr, 4);
    return 0;
}
Output

11 ---> 3
13 ---> 3
21 ---> 3
3 ---> -1
Time Complexity : O(N(log(N))^2)   

For each of n array elements we do a binary search, which includes  log(N)        steps, and each step costs log(N)        operations [range minimum queries].

Auxiliary Space: O(N)

// BY SHIBAM NATH
